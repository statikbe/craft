{"version":3,"file":"scroll-timeline.js","sources":["../src/tokenizer.js","../src/utils.js","../src/simplify-calculation.js","../src/numeric-values.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/scroll-timeline-css-parser.js","../src/scroll-timeline-css.js","../src/index.js","../src/init-polyfill.js"],"sourcesContent":["\nexport class Token {}\n\n// The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>,\n// <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>,\n// <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>,\n// <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.\nexport class IdentToken extends Token {\n  value;\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nexport class FunctionToken extends Token {\n  value;\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nexport class AtKeywordToken extends Token {\n  value;\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nexport class HashToken extends Token {\n  type;\n  value;\n  constructor(value, type = 'unrestricted') {\n    super();\n    this.value = value;\n    this.type = type;\n  }\n}\n\nexport class StringToken extends Token {\n  value;\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nexport class BadStringToken extends Token {}\n\nexport class UrlToken extends Token {\n  value;\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nexport class BadUrlToken extends Token {}\n\nexport class DelimToken extends Token {\n  value;\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nexport class NumberToken extends Token {\n  value;\n  type;\n  constructor(value, type = \"integer\") {\n    super();\n    this.value = value;\n    this.type = type;\n  }\n}\n\nexport class PercentageToken extends Token {\n  value;\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nexport class DimensionToken extends Token {\n  value;\n  type;\n  unit;\n  constructor(value, type, unit) {\n    super();\n    this.value = value;\n    this.type = type;\n    this.unit = unit;\n  }\n}\n\nexport class WhitespaceToken extends Token {}\n\nexport class CDOToken extends Token {}\n\nexport class CDCToken extends Token {}\n\nexport class ColonToken extends Token {}\n\nexport class SemicolonToken extends Token {}\n\nexport class CommaToken extends Token {}\n\nexport class LeftSquareBracketToken extends Token {}\n\nexport class RightSquareBracketToken extends Token {}\n\nexport class LeftParenthesisToken extends Token {}\n\nexport class RightParenthesisToken extends Token {}\n\nexport class LeftCurlyBracketToken extends Token {}\n\nexport class RightCurlyBracketToken extends Token {}\n\nclass InputStream {\n  input\n  index = 0;\n  constructor(input) {\n    this.input = input;\n  }\n\n  consume() {\n    const codePoint = this.input.codePointAt(this.index);\n    if (typeof codePoint !== 'undefined') {\n      this.index += String.fromCodePoint(codePoint).length;\n    }\n    return codePoint;\n  }\n\n  reconsume(codePoint) {\n    if (typeof codePoint !== 'undefined') {\n      this.index -= String.fromCodePoint(codePoint).length\n    }\n  }\n\n  peek() {\n    const codePoints = []\n    let position = this.index\n    for (let i = 0; i < 3 && position < this.input.length; i++) {\n      const nextCodePoint = this.input.codePointAt(position);\n      codePoints.push(nextCodePoint);\n      position += String.fromCodePoint(nextCodePoint).length;\n    }\n    return codePoints;\n  }\n}\n\nfunction isNewline(codePoint) {\n  // U+000A LINE FEED.\n  return codePoint === 0x000A;\n}\nfunction isWhitespace(codePoint) {\n  // A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.\n  return isNewline(codePoint) || codePoint === 0x2000 || codePoint === 0x0020;\n}\n\nfunction isDigit(codePoint) {\n  // A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9) inclusive.\n  return codePoint >= 0x0030 && codePoint <=0x0039;\n}\n\nfunction isHexDigit(codePoint) {\n  // A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F) inclusive,\n  // or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f) inclusive.\n  return isDigit(codePoint) ||\n    (codePoint >= 0x0041 && codePoint <= 0x0046) ||\n    (codePoint >= 0x0061 && codePoint <= 0x0066);\n}\n\nfunction isUppercaseLetter(codePoint) {\n  // A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z) inclusive.\n  return codePoint >= 0x0041 && codePoint <= 0x005A;\n}\n\nfunction isLowercaseLetter(codePoint) {\n  // A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z) inclusive.\n  return codePoint >= 0x0061 && codePoint <= 0x007A;\n}\n\nfunction isLetter(codePoint) {\n  // An uppercase letter or a lowercase letter.\n  return isUppercaseLetter(codePoint) || isLowercaseLetter(codePoint);\n}\n\nfunction nonASCIICodePoint(codePoint) {\n  // A code point with a value equal to or greater than U+0080 <control>.\n  return codePoint >= 0x0080;\n}\nfunction isIdentStartCodePoint(codePoint) {\n  // A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n  return isLetter(codePoint) || nonASCIICodePoint(codePoint) || codePoint === 0x005F;\n}\n\nfunction isIdentCodePoint(codePoint) {\n  // An ident-start code point, a digit, or U+002D HYPHEN-MINUS (-).\n  return isIdentStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === 0x002D;\n}\n\nfunction isNonPrintableCodePoint(codePoint) {\n  // A code point between U+0000 NULL and U+0008 BACKSPACE inclusive, or U+000B LINE TABULATION,\n  // or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE inclusive, or U+007F DELETE.\n  return (codePoint >= 0x0000 && codePoint <= 0x0008) || codePoint === 0x000B ||\n    (codePoint >= 0x000E && codePoint <= 0x001F) || codePoint === 0x007F;\n}\n\nfunction validEscape(firstCodePoint, secondCodePoint) {\n  // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n  // Otherwise, if the second code point is a newline, return false.\n  // Otherwise, return true.\n  return firstCodePoint === 0x005C && !isNewline(secondCodePoint);\n}\n\nfunction startsIdentSequence(firstCodePoint, secondCodePoint, thirdCodePoint) {\n  // Look at the first code point:\n  if (firstCodePoint === 0x002D) {\n    // U+002D HYPHEN-MINUS\n    // If the second code point is an ident-start code point or a U+002D HYPHEN-MINUS,\n    // or the second and third code points are a valid escape, return true. Otherwise, return false.\n    return isIdentStartCodePoint(secondCodePoint) || secondCodePoint === 0x002D ||\n      validEscape(secondCodePoint, thirdCodePoint);\n  } else if (isIdentStartCodePoint(firstCodePoint)) {\n    // ident-start code point\n    // Return true.\n    return true;\n  } else if (firstCodePoint === 0x005C) {\n    // U+005C REVERSE SOLIDUS (\\)\n    // If the first and second code points are a valid escape, return true. Otherwise, return false.\n    return validEscape(firstCodePoint, secondCodePoint);\n  } else {\n    // anything else\n    // Return false.\n    return false;\n  }\n}\n\nfunction startsNumber(firstCodePoint, secondCodePoint, thirdCodePoint) {\n  // https://www.w3.org/TR/css-syntax-3/#check-if-three-code-points-would-start-a-number\n  // Look at the first code point:\n\n  if (firstCodePoint === 0x002B || firstCodePoint === 0x002D) {\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    // If the second code point is a digit, return true.\n    // Otherwise, if the second code point is a U+002E FULL STOP (.) and the third code point is a digit, return true.\n    //\n    // Otherwise, return false.\n    return isDigit(secondCodePoint) || (secondCodePoint === 0x002E && isDigit(thirdCodePoint));\n  } else if (firstCodePoint === 0x002E) {\n    // U+002E FULL STOP (.)\n    // If the second code point is a digit, return true. Otherwise, return false.\n    return isDigit(secondCodePoint);\n  } else {\n    // digit\n    // Return true.\n    // anything else\n    // Return false.\n    return isDigit(firstCodePoint);\n  }\n}\n\n/**\n * Consume an escaped code point\n * https://www.w3.org/TR/css-syntax-3/#consume-an-escaped-code-point\n *\n * @param {InputStream} input\n * @return number\n */\nfunction consumeEscapedCodePoint(input) {\n  // Consume the next input code point.\n  const codePoint = input.consume();\n  if (isHexDigit(codePoint)) {\n    let digits = [codePoint];\n    // hex digit\n    // Consume as many hex digits as possible, but no more than 5. Note that this means 1-6 hex digits have been\n    // consumed in total.\n    while(isHexDigit(...input.peek()) && digits.length < 5) {\n      digits.push(input.consume());\n    }\n\n    // If the next input code point is whitespace, consume it as well.\n    if (isWhitespace(...input.peek())) {\n      input.consume();\n    }\n\n    // Interpret the hex digits as a hexadecimal number. If this number is zero, or is for a surrogate, or is greater\n    // than the maximum allowed code point, return U+FFFD REPLACEMENT CHARACTER (�). Otherwise, return the code point\n    // with that value.\n    const number = parseInt(String.fromCodePoint(...digits), 16);\n    if (number === 0 || number > 0x10FFFF) {\n      return 0xFFFD;\n    } else {\n      return number;\n    }\n  } else if (typeof codePoint === 'undefined') {\n    // EOF\n    // This is a parse error. Return U+FFFD REPLACEMENT CHARACTER (�).\n    return 0xFFFD;\n  } else {\n    // anything else\n    // Return the current input code point.\n    return codePoint;\n  }\n}\n\n\n/**\n * Consume a string token\n * https://www.w3.org/TR/css-syntax-3/#consume-a-string-token\n *\n * @param {InputStream} input\n * @param {number} endingCodePoint\n */\nfunction consumeStringToken(input, endingCodePoint) {\n  const stringToken = new StringToken('');\n\n  while (true) {\n    // Repeatedly consume the next input code point from the stream:\n    const codePoint = input.consume();\n    if (codePoint === endingCodePoint) {\n      // ending code point\n      // Return the <string-token>.\n      return stringToken;\n    } else if (typeof codePoint === 'undefined') {\n      // EOF\n      // This is a parse error. Return the <string-token>.\n      return stringToken\n    } else if (codePoint === 0x00A) {\n      // newline\n      // This is a parse error. Reconsume the current input code point, create a <bad-string-token>, and return it.\n      input.reconsume(codePoint);\n      return new BadStringToken();\n    } else if (codePoint === 0x005C) {\n      // U+005C REVERSE SOLIDUS (\\)\n      const nextCodePoint = input.peek()[0];\n      if (typeof nextCodePoint === 'undefined') {\n        // If the next input code point is EOF, do nothing.\n      } else if (isNewline(nextCodePoint)) {\n        // Otherwise, if the next input code point is a newline, consume it.\n        input.consume();\n      } else {\n        // Otherwise, (the stream starts with a valid escape) consume an escaped code point and\n        // append the returned code point to the <string-token>’s value.\n        stringToken.value += String.fromCodePoint(consumeEscapedCodePoint(input));\n      }\n    } else {\n      // anything else\n      // Append the current input code point to the <string-token>’s value.\n      stringToken.value += String.fromCodePoint(codePoint);\n    }\n  }\n}\n\n/**\n * Consume ident sequence\n * https://www.w3.org/TR/css-syntax-3/#consume-name\n *\n * @param {InputStream} input\n */\nfunction consumeIdentSequence(input) {\n  // Let result initially be an empty string.\n  let result = '';\n\n  // Repeatedly consume the next input code point from the stream:\n  while (true) {\n    const codePoint = input.consume();\n    if (isIdentCodePoint(codePoint)) {\n      // ident code point\n      // Append the code point to result.\n      result += String.fromCodePoint(codePoint);\n    } else if (validEscape(...input.peek())) {\n      // the stream starts with a valid escape\n      // Consume an escaped code point. Append the returned code point to result.\n      result += String.fromCodePoint(consumeEscapedCodePoint(input));\n    } else {\n      // anything else\n      // Reconsume the current input code point. Return result.\n      input.reconsume(codePoint);\n      return result;\n    }\n  }\n}\n\n/**\n * Consume a number\n * https://www.w3.org/TR/css-syntax-3/#consume-a-number\n *\n * @param {InputStream} input\n */\nfunction consumeNumber(input) {\n  // Execute the following steps in order:\n  //\n  // Initially set type to \"integer\". Let repr be the empty string.\n  let type = 'integer';\n  let repr = '';\n\n  // If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), consume it and append it to repr.\n  if ([0x002B, 0x002D].includes(input.peek()[0])) {\n    repr += String.fromCodePoint(input.consume());\n  }\n\n  // While the next input code point is a digit, consume it and append it to repr.\n  while(isDigit(...input.peek())) {\n    repr += String.fromCodePoint(input.consume());\n  }\n\n  // If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n  //   Consume them.\n  //   Append them to repr.\n  //   Set type to \"number\".\n  //   While the next input code point is a digit, consume it and append it to repr.\n  if (input.peek()[0] === 0x002E && isDigit(input.peek()[1])) {\n    repr += String.fromCodePoint(input.consume(), input.consume());\n    type = 'number';\n    while(isDigit(...input.peek())) {\n      repr += String.fromCodePoint(input.consume());\n    }\n  }\n\n  // If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e),\n  // optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+),\n  // followed by a digit, then:\n  //   Consume them.\n  //   Append them to repr.\n  //   Set type to \"number\".\n  //   While the next input code point is a digit, consume it and append it to repr.\n  if ([0x0045, 0x0065].includes(input.peek()[0])) {\n    if ([0x002D, 0x002B].includes(input.peek()[1]) && isDigit(input.peek()[2])) {\n      repr += String.fromCodePoint(input.consume(), input.consume(), input.consume());\n      type = 'number';\n    } else if (isDigit(input.peek()[1])) {\n      repr += String.fromCodePoint(input.consume(), input.consume());\n      type = 'number';\n    }\n  }\n\n  // Convert repr to a number, and set the value to the returned value.\n  const value = parseFloat(repr);\n  // Return value and type.\n  return { value, type };\n}\n\n/**\n * Consume a numeric token\n * https://www.w3.org/TR/css-syntax-3/#consume-a-numeric-token\n *\n * @param {InputStream} input\n */\nfunction consumeNumericToken(input) {\n  // Consume a number and let number be the result.\n  let number = consumeNumber(input);\n  // If the next 3 input code points would start an ident sequence, then:\n  if (startsIdentSequence(...input.peek())) {\n    // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n    // Consume an ident sequence. Set the <dimension-token>’s unit to the returned value.\n    // Return the <dimension-token>.\n    return new DimensionToken(number.value, number.type, consumeIdentSequence(input));\n  } else if (input.peek()[0] === 0x0025) {\n    // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n    // Create a <percentage-token> with the same value as number, and return it.\n    input.consume();\n    return new PercentageToken(number.value);\n  } else {\n    // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n    return new NumberToken(number.value, number.type);\n  }\n}\n\n/**\n * Consume remnants of a bad url\n * https://www.w3.org/TR/css-syntax-3/#consume-the-remnants-of-a-bad-url\n * @param {InputStream} input\n */\nfunction consumeRemnantsOfBadUrl(input) {\n  // Repeatedly consume the next input code point from the stream:\n  while (true) {\n    const codePoint = input.consume();\n    if (codePoint === 0x0029 || typeof codePoint === 'undefined') {\n      // U+0029 RIGHT PARENTHESIS ())\n      // EOF\n      // Return.\n      return;\n    } else if (validEscape(...input.peek())) {\n      // the input stream starts with a valid escape\n      // Consume an escaped code point. This allows an escaped right parenthesis (\"\\)\") to be encountered without\n      // ending the <bad-url-token>. This is otherwise identical to the \"anything else\" clause.\n      consumeEscapedCodePoint(input);\n    }\n    // anything else\n    // Do nothing.\n  }\n}\n\n/**\n * Consume URL token\n * https://www.w3.org/TR/css-syntax-3/#consume-a-url-token\n * @param {InputStream} input\n */\nfunction consumeUrlToken(input) {\n  // Initially create a <url-token> with its value set to the empty string.\n  const urlToken = new UrlToken('');\n\n  // Consume as much whitespace as possible.\n  while(isWhitespace(...input.peek())) {\n    input.consume();\n  }\n\n  // Repeatedly consume the next input code point from the stream:\n  while (true) {\n    const codePoint = input.consume();\n    if (codePoint === 0x0029) {\n\n      // U+0029 RIGHT PARENTHESIS ())\n      // Return the <url-token>.\n      return urlToken;\n    } else if (typeof codePoint === 'undefined') {\n      // EOF\n      // This is a parse error. Return the <url-token>.\n      return urlToken;\n    } else if (isWhitespace(codePoint)) {\n      // whitespace\n      // Consume as much whitespace as possible.\n      while(isWhitespace(...input.peek())) {\n        input.consume();\n      }\n      if (input.peek()[0] === 0x0029 || typeof input.peek()[0] === 'undefined') {\n        // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,\n        // consume it and return the <url-token> (if EOF was encountered, this is a parse error);\n        input.consume();\n        return urlToken;\n      } else {\n        // otherwise, consume the remnants of a bad url, create a <bad-url-token>, and return it.\n        consumeRemnantsOfBadUrl(input);\n        return new BadUrlToken();\n      }\n    } else if ([0x0022, 0x0027, 0x0028].includes(codePoint) || isNonPrintableCodePoint(codePoint)) {\n      // U+0022 QUOTATION MARK (\")\n      // U+0027 APOSTROPHE (')\n      // U+0028 LEFT PARENTHESIS (()\n      // non-printable code point\n      // This is a parse error. Consume the remnants of a bad url, create a <bad-url-token>, and return it.\n      consumeRemnantsOfBadUrl(input);\n      return new BadUrlToken();\n    } else if (codePoint === 0x005C) {\n      // U+005C REVERSE SOLIDUS (\\)\n      if (validEscape(...input.peek())) {\n        // If the stream starts with a valid escape,\n        // consume an escaped code point and append the returned code point to the <url-token>’s value.\n        urlToken.value += consumeEscapedCodePoint(input);\n      } else {\n        // Otherwise, this is a parse error. Consume the remnants of a bad url, create a <bad-url-token>, and return it.\n        consumeRemnantsOfBadUrl(input);\n        return new BadUrlToken();\n      }\n    } else {\n      // anything else\n      // Append the current input code point to the <url-token>’s value.\n      urlToken.value += String.fromCodePoint(codePoint);\n    }\n  }\n}\n\n/**\n * Consume ident like token\n * https://www.w3.org/TR/css-syntax-3/#consume-an-ident-like-token\n *\n * @param {InputStream} input\n */\nfunction consumeIdentLikeToken(input) {\n  // Consume an ident sequence, and let string be the result.\n  const str = consumeIdentSequence(input);\n  if (str.match(/url/i) && input.peek()[0] === 0x0028) {\n    // If string’s value is an ASCII case-insensitive match for \"url\",\n    // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n    input.consume();\n    // While the next two input code points are whitespace, consume the next input code point.\n    while(isWhitespace(input.peek()[0]) && isWhitespace(input.peek()[1])) {\n      input.consume();\n    }\n\n    if ([0x0022, 0x0027].includes(input.peek()[0]) ||\n      (isWhitespace(input.peek()[0]) && [0x0022, 0x0027].includes(input.peek()[1]))) {\n      // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),\n      // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('),\n      // then create a <function-token> with its value set to string and return it.\n      return new FunctionToken(str);\n    } else {\n      // Otherwise, consume a url token, and return it.\n      return consumeUrlToken(input);\n    }\n  } else if (input.peek()[0] === 0x0028) {\n    // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n    // Create a <function-token> with its value set to string and return it.\n    input.consume();\n    return new FunctionToken(str);\n  } else {\n    // Otherwise, create an <ident-token> with its value set to string and return it.\n    return new IdentToken(str);\n  }\n}\n/**\n * Consume a token.\n *\n * https://www.w3.org/TR/css-syntax-3/#consume-a-token\n *\n * @param {InputStream} input\n */\nfunction consumeToken(input) {\n  // Consume the next input code point\n  const codePoint = input.consume()\n  const lookahead = input.peek()\n  if (isWhitespace(codePoint)) {\n    // whitespace\n    // Consume as much whitespace as possible. Return a <whitespace-token>.\n    while(isWhitespace(...input.peek())) {\n      input.consume();\n    }\n    return new WhitespaceToken();\n  } else if (codePoint === 0x0022) {\n    // U+0022 QUOTATION MARK (\")\n    // Consume a string token and return it.\n    return consumeStringToken(input, codePoint);\n  } else if (codePoint === 0x0023) {\n    // U+0023 NUMBER SIGN (#)\n    // If the next input code point is an ident code point or the next two input code points are a valid escape, then:\n    //   Create a <hash-token>.\n    //   If the next 3 input code points would start an ident sequence, set the <hash-token>’s type flag to \"id\".\n    //   Consume an ident sequence, and set the <hash-token>’s value to the returned string.\n    //   Return the <hash-token>.\n    // Otherwise, return a <delim-token> with its value set to the current input code point.\n    if (isIdentCodePoint(lookahead[0]) || validEscape(...lookahead)) {\n      const hashToken = new HashToken();\n      if (startsIdentSequence(...lookahead)) {\n        hashToken.type = 'id';\n      }\n      hashToken.value = consumeIdentSequence(input);\n      return hashToken;\n    } else {\n      return new DelimToken(String.fromCodePoint(codePoint));\n    }\n  } else if (codePoint === 0x0027) {\n    // U+0027 APOSTROPHE (')\n    // Consume a string token and return it.\n    return consumeStringToken(input, codePoint);\n  } else if (codePoint === 0x0028) {\n    // U+0028 LEFT PARENTHESIS (()\n    // Return a <(-token>.\n    return new LeftParenthesisToken();\n  } else if (codePoint === 0x0029) {\n    // U+0029 RIGHT PARENTHESIS ())\n    // Return a <)-token>.\n    return new RightParenthesisToken();\n  } else if (codePoint === 0x002B) {\n    // U+002B PLUS SIGN (+)\n    // If the input stream starts with a number, reconsume the current input code point, consume a numeric token,\n    // and return it.\n    // Otherwise, return a <delim-token> with its value set to the current input code point.\n    if (startsNumber(...lookahead)) {\n      input.reconsume(codePoint);\n      return consumeNumericToken(input);\n    } else {\n      return new DelimToken(String.fromCodePoint(codePoint));\n    }\n  } else if (codePoint === 0x002C) {\n    // U+002C COMMA (,)\n    // Return a <comma-token>.\n    return new CommaToken();\n  } else if (codePoint === 0x002D) {\n    // U+002D HYPHEN-MINUS (-)\n    if (startsNumber(...input.peek())) {\n      // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n      input.reconsume(codePoint);\n      return consumeNumericToken(input);\n    } else if (input.peek()[0] === 0x002D && input.peek()[1] === 0x003E) {\n      // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n      input.consume();\n      input.consume();\n      return new CDCToken();\n    } else if (startsIdentSequence(...input.peek())) {\n      // Otherwise, if the input stream starts with an ident sequence, reconsume the current input code point, consume an ident-like token, and return it.\n      input.reconsume(codePoint);\n      return consumeIdentLikeToken(input);\n    } else {\n      // Otherwise, return a <delim-token> with its value set to the current input code point.\n      return new DelimToken(String.fromCodePoint(codePoint));\n    }\n  } else if (codePoint === 0x002E) {\n    // U+002E FULL STOP (.)\n    if (startsNumber(...input.peek())) {\n      // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n      input.reconsume(codePoint);\n      return consumeNumericToken(input);\n    } else {\n      // Otherwise, return a <delim-token> with its value set to the current input code point.\n      return new DelimToken(String.fromCodePoint(codePoint));\n    }\n  } else if (codePoint === 0x003A) {\n    // U+003A COLON (:)\n    // Return a <colon-token>.\n    return new ColonToken();\n  } else if (codePoint === 0x003B) {\n    // U+003B SEMICOLON (;)\n    // Return a <semicolon-token>.\n    return new SemicolonToken();\n  } else if (codePoint === 0x003C) {\n    // U+003C LESS-THAN SIGN (<)\n    if (lookahead[0] === 0x0021 && lookahead[1] === 0x002D && lookahead[2] === 0x002D) {\n      // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), consume them and return a <CDO-token>.\n      input.consume();\n      input.consume();\n      input.consume();\n      return new CDOToken();\n    } else {\n      // Otherwise, return a <delim-token> with its value set to the current input code point.\n      return new DelimToken(String.fromCodePoint(codePoint));\n    }\n  } else if (codePoint === 0x0040) {\n    // U+0040 COMMERCIAL AT (@)\n    if (startsIdentSequence(...lookahead)) {\n      // If the next 3 input code points would start an ident sequence, consume an ident sequence,\n      // create an <at-keyword-token> with its value set to the returned value, and return it.\n      return new AtKeywordToken(consumeIdentSequence(input));\n    } else {\n      // Otherwise, return a <delim-token> with its value set to the current input code point.\n      return new DelimToken(String.fromCodePoint(codePoint));\n    }\n  } else if (codePoint === 0x005B) {\n    // U+005B LEFT SQUARE BRACKET ([)\n    // Return a <[-token>.\n    return new LeftSquareBracketToken();\n  } else if (codePoint === 0x005C) {\n    // U+005C REVERSE SOLIDUS (\\)\n    if (validEscape(...lookahead)) {\n      // If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.\n      input.reconsume(codePoint);\n      return consumeIdentLikeToken(input);\n    } else {\n      // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n      return new DelimToken(String.fromCodePoint(codePoint));\n    }\n  } else if (codePoint === 0x005D) {\n    // U+005D RIGHT SQUARE BRACKET (])\n    // Return a <]-token>.\n    return new RightSquareBracketToken();\n  } else if (codePoint === 0x007B) {\n    // U+007B LEFT CURLY BRACKET ({)\n    // Return a <{-token>.\n    return new LeftCurlyBracketToken();\n  } else if (codePoint === 0x007D) {\n    // U+007D RIGHT CURLY BRACKET (})\n    // Return a <}-token>.\n    return new RightCurlyBracketToken();\n  } else if (isDigit(codePoint)) {\n    // digit\n    // Reconsume the current input code point, consume a numeric token, and return it.\n    input.reconsume(codePoint);\n    return consumeNumericToken(input);\n  } else if (isIdentStartCodePoint(codePoint)) {\n    // ident-start code point\n    // Reconsume the current input code point, consume an ident-like token, and return it.\n    input.reconsume(codePoint);\n    return consumeIdentLikeToken(input);\n  } else if (typeof codePoint === 'undefined') {\n    // EOF\n    // Return an <EOF-token>.\n    return undefined;\n  } else {\n    // anything else\n    // Return a <delim-token> with its value set to the current input code point.\n    return new DelimToken(String.fromCodePoint(codePoint));\n  }\n}\n\n/**\n * Tokenize a string into an array of CSS tokens.\n * @param {string} str\n */\nexport function tokenizeString(str) {\n  const input = new InputStream(str);\n  // To tokenize a stream of code points into a stream of CSS tokens input, repeatedly consume a token from input\n  // until an <EOF-token> is reached, pushing each of the returned tokens into a stream.\n  const tokens = [];\n  while (true) {\n    const token = consumeToken(input);\n    if (typeof token === 'undefined') {\n      return tokens;\n    } else {\n      tokens.push(token);\n    }\n  }\n}","const canonicalUnits = new Set([\"px\", \"deg\", \"s\", \"hz\", \"dppx\", \"number\", \"fr\"]);\n\nexport function isCanonical(unit) {\n  return canonicalUnits.has(unit.toLowerCase());\n}\n\nexport function normalizeAxis(axis, computedStyle) {\n  if (['x','y'].includes(axis)) return axis;\n\n  if (!computedStyle) {\n    throw new Error('To determine the normalized axis the computedStyle of the source is required.');\n  }\n\n  const horizontalWritingMode = computedStyle.writingMode == 'horizontal-tb';\n  if (axis === \"block\") {\n    axis = horizontalWritingMode ? \"y\" : \"x\";\n  } else if (axis === \"inline\") {\n    axis = horizontalWritingMode ? \"x\" : \"y\";\n  } else {\n    throw new TypeError(`Invalid axis “${axis}”`);\n  }\n\n  return axis;\n}\n\n/**\n * Split an input string into a list of individual component value strings,\n * so that each can be handled as a keyword or parsed with `CSSNumericValue.parse()`;\n *\n * Examples:\n * splitIntoComponentValues('cover'); // ['cover']\n * splitIntoComponentValues('auto 0%'); // ['auto', '100%']\n * splitIntoComponentValues('calc(0% + 50px) calc(100% - 50px)'); // ['calc(0% + 50px)', 'calc(100% - 50px)']\n * splitIntoComponentValues('1px 2px').map(val => CSSNumericValue.parse(val)) // [new CSSUnitValue(1, 'px'), new CSSUnitValue(2, 'px')]\n *\n * @param {string} input\n * @return {string[]}\n */\nexport function splitIntoComponentValues(input) {\n  const res = [];\n  let i = 0;\n\n  function consumeComponentValue() {\n    let level = 0;\n    const startIndex = i;\n    while (i < input.length) {\n      const nextChar = input.slice(i, i + 1);\n      if (/\\s/.test(nextChar) && level === 0) {\n        break;\n      } else if (nextChar === '(') {\n        level += 1;\n      } else if (nextChar === ')') {\n        level -= 1;\n        if (level === 0) {\n          // Consume the next character and break\n          i++;\n          break;\n        }\n      }\n      i++;\n    }\n    return input.slice(startIndex, i);\n  }\n\n  function consumeWhitespace() {\n    while (/\\s/.test(input.slice(i, i + 1))) {\n      i++;\n    }\n  }\n\n  while(i < input.length) {\n    const nextChar = input.slice(i, i + 1);\n    if (/\\s/.test(nextChar)) {\n      consumeWhitespace();\n    } else {\n      res.push(consumeComponentValue());\n    }\n  }\n  return res;\n}","import {isCanonical} from \"./utils\";\n\n/**\n * @typedef {{percentageReference: CSSUnitValue, fontSize?: CSSUnitValue}} Info\n */\n\n/**\n * Groups a list of objects by a given string keyed property\n *\n * @template T\n * @param {T[]} items\n * @param {string} key string key\n * @return {Map<any,T[]>}\n */\nfunction groupBy(items, key) {\n  return items.reduce((groups, item) => {\n    if (groups.has(item[key])) {\n      groups.get(item[key]).push(item);\n    } else {\n      groups.set(item[key], [item]);\n    }\n    return groups;\n  }, new Map());\n}\n\n/**\n * Partitions a list into a tuple of lists.\n * The first item in the tuple contains a list of items that pass the test provided by the callback function.\n * The second item in the tuple contains the remaining items\n *\n * @template T\n * @param {T[]} items\n * @param {(item:T) => boolean} callbackFn Returns truthy if item should be put in the first list in the tuple, falsy if it should be put in the second list.\n * @return {[T[],T[]]}\n */\nfunction partition(items, callbackFn) {\n  const partA = [];\n  const partB = [];\n  for (const item of items) {\n    if (callbackFn(item)) {\n      partA.push(item);\n    } else {\n      partB.push(item);\n    }\n  }\n  return [partA, partB];\n}\n\n/**\n * Partial implementation of `simplify a calculation tree` applied to CSSNumericValue\n * https://www.w3.org/TR/css-values-4/#simplify-a-calculation-tree\n *\n * @param {CSSNumericValue} root\n * @param {Info} info information used to resolve\n * @return {CSSNumericValue}\n */\nexport function simplifyCalculation(root, info = {}) {\n  function simplifyNumericArray(values) {\n    return Array.from(values).map((value) => simplifyCalculation(value, info));\n  }\n\n  // To simplify a calculation tree root:\n  if (root instanceof CSSUnitValue) {\n    // 1. If root is a numeric value:\n\n    if (root.unit === \"percent\" && info.percentageReference) {\n      // 1. If root is a percentage that will be resolved against another value, and there is enough information\n      //    available to resolve it, do so, and express the resulting numeric value in the appropriate canonical unit.\n      //    Return the value.\n      const resolvedValue = (root.value / 100) * info.percentageReference.value;\n      const resolvedUnit = info.percentageReference.unit;\n      return new CSSUnitValue(resolvedValue, resolvedUnit);\n    }\n\n    // 2. If root is a dimension that is not expressed in its canonical unit, and there is enough information available\n    //    to convert it to the canonical unit, do so, and return the value.\n\n    // Use Typed OM toSum() to convert values in compatible sets to canonical units\n    const sum = root.toSum();\n    if (sum && sum.values.length === 1) {\n      root = sum.values[0];\n    }\n    // TODO: handle relative lengths\n    if (root instanceof CSSUnitValue && root.unit === 'em' && info.fontSize) {\n      root = new CSSUnitValue(root.value * info.fontSize.value, info.fontSize.unit);\n    }\n    // 3. If root is a <calc-keyword> that can be resolved, return what it resolves to, simplified.\n    if (root instanceof CSSKeywordValue) {\n      //https://www.w3.org/TR/css-values-4/#calc-constants\n      if (root.value === 'e') {\n        return new CSSUnitValue(Math.E, 'number');\n      } else if (root.value === 'pi') {\n        return new CSSUnitValue(Math.PI, 'number');\n      }\n    }\n    // 4. Otherwise, return root.\n    return root;\n  }\n\n  // 2. If root is any other leaf node (not an operator node):\n  if (!root.operator) {\n    //    1. If there is enough information available to determine its numeric value, return its value, expressed in the value’s canonical unit.\n    //    2. Otherwise, return root.\n    return root;\n  }\n\n  // 3. At this point, root is an operator node. Simplify all the calculation children of root.\n  switch (root.operator) {\n    case \"sum\":\n      root = new CSSMathSum(...simplifyNumericArray(root.values));\n      break;\n    case \"product\":\n      root = new CSSMathProduct(...simplifyNumericArray(root.values));\n      break;\n    case \"negate\":\n      root = new CSSMathNegate(simplifyCalculation(root.value, info));\n      break;\n    case \"clamp\":\n      root = new CSSMathClamp(simplifyCalculation(root.lower, info), simplifyCalculation(root.value, info),\n        simplifyCalculation(root.upper, info));\n      break;\n    case \"invert\":\n      root = new CSSMathInvert(simplifyCalculation(root.value, info));\n      break;\n    case \"min\":\n      root = new CSSMathMin(...simplifyNumericArray(root.values));\n      break;\n    case \"max\":\n      root = new CSSMathMax(...simplifyNumericArray(root.values));\n      break;\n  }\n\n  // 4. If root is an operator node that’s not one of the calc-operator nodes, and all of its calculation children are\n  //    numeric values with enough information to compute the operation root represents, return the result of running\n  //    root’s operation using its children, expressed in the result’s canonical unit.\n  if (root instanceof CSSMathMin || root instanceof CSSMathMax) {\n    const children = Array.from(root.values);\n    if (children.every(\n      (child) => child instanceof CSSUnitValue && child.unit !== \"percent\" && isCanonical(child.unit) && child.unit ===\n        children[0].unit)) {\n\n      const result = Math[root.operator].apply(Math, children.map(({value}) => value));\n      return new CSSUnitValue(result, children[0].unit);\n    }\n  }\n\n  //    Note: If a percentage is left at this point, it will usually block simplification of the node, since it needs to be\n  //    resolved against another value using information not currently available. (Otherwise, it would have been converted\n  //    to a different value in an earlier step.) This includes operations such as \"min\", since percentages might resolve\n  //    against a negative basis, and thus end up with an opposite comparative relationship than the raw percentage value\n  //    would seem to indicate.\n  //\n  //    However, \"raw\" percentages—ones which do not resolve against another value, such as in opacity—might not block\n  //    simplification.\n\n  // 5. If root is a Min or Max node, attempt to partially simplify it:\n  if (root instanceof CSSMathMin || root instanceof CSSMathMax) {\n    const children = Array.from(root.values);\n    const [numeric, rest] = partition(children, (child) => child instanceof CSSUnitValue && child.unit !== \"percent\");\n    const unitGroups = Array.from(groupBy(numeric, \"unit\").values());\n    //    1. For each node child of root’s children:\n    //\n    //       If child is a numeric value with enough information to compare magnitudes with another child of the same\n    //       unit (see note in previous step), and there are other children of root that are numeric children with the same\n    //       unit, combine all such children with the appropriate operator per root, and replace child with the result,\n    //       removing all other child nodes involved.\n    const hasComparableChildren = unitGroups.some(group => group.length > 0);\n    if (hasComparableChildren) {\n      const combinedGroups = unitGroups.map(group => {\n        const result = Math[root.operator].apply(Math, group.map(({value}) => value));\n        return new CSSUnitValue(result, group[0].unit);\n      });\n      if (root instanceof CSSMathMin) {\n        root = new CSSMathMin(...combinedGroups, ...rest);\n      } else {\n        root = new CSSMathMax(...combinedGroups, ...rest);\n      }\n    }\n\n    //    2. If root has only one child, return the child.\n    //\n    //       Otherwise, return root.\n    if (children.length === 1) {\n      return children[0];\n    } else {\n      return root;\n    }\n  }\n\n  // If root is a Negate node:\n  //\n  // If root’s child is a numeric value, return an equivalent numeric value, but with the value negated (0 - value).\n  // If root’s child is a Negate node, return the child’s child.\n  // Return root.\n  if (root instanceof CSSMathNegate) {\n    if (root.value instanceof CSSUnitValue) {\n      return new CSSUnitValue(0 - root.value.value, root.value.unit);\n    } else if (root.value instanceof CSSMathNegate) {\n      return root.value.value;\n    } else {\n      return root;\n    }\n  }\n\n  // If root is an Invert node:\n  //\n  // If root’s child is a number (not a percentage or dimension) return the reciprocal of the child’s value.\n  // If root’s child is an Invert node, return the child’s child.\n  // Return root.\n  if (root instanceof CSSMathInvert) {\n    if (root.value instanceof CSSMathInvert) {\n      return root.value.value;\n    } else {\n      return root;\n    }\n  }\n\n  // If root is a Sum node:\n  if (root instanceof CSSMathSum) {\n    let children = [];\n    // For each of root’s children that are Sum nodes, replace them with their children.\n    for (const value of root.values) {\n      if (value instanceof CSSMathSum) {\n        children.push(...value.values);\n      } else {\n        children.push(value);\n      }\n    }\n\n    // For each set of root’s children that are numeric values with identical units, remove those children and\n    // replace them with a single numeric value containing the sum of the removed nodes, and with the same unit.\n    //\n    // (E.g. combine numbers, combine percentages, combine px values, etc.)\n    function sumValuesWithSameUnit(values) {\n      const numericValues = values.filter((c) => c instanceof CSSUnitValue);\n      const nonNumericValues = values.filter((c) => !(c instanceof CSSUnitValue));\n\n      const summedNumericValues = Array.from(groupBy(numericValues, \"unit\").entries())\n        .map(([unit, values]) => {\n          const sum = values.reduce((a, {value}) => a + value, 0);\n          return new CSSUnitValue(sum, unit);\n        });\n      return [...nonNumericValues, ...summedNumericValues];\n    }\n\n    children = sumValuesWithSameUnit(children);\n\n    // If root has only a single child at this point, return the child. Otherwise, return root.\n    // NOTE: Zero-valued terms cannot be simply removed from a Sum; they can only be combined with other values\n    // that have identical units. (This is because the mere presence of a unit, even with a zero value,\n    // can sometimes imply a change in behavior.)\n    if (children.length === 1) {\n      return children[0];\n    } else {\n      return new CSSMathSum(...children);\n    }\n  }\n\n  // If root is a Product node:\n  //\n  // For each of root’s children that are Product nodes, replace them with their children.\n  if (root instanceof CSSMathProduct) {\n    let children = [];\n    for (const value of root.values) {\n      if (value instanceof CSSMathProduct) {\n        children.push(...value.values);\n      } else {\n        children.push(value);\n      }\n    }\n\n    // If root has multiple children that are numbers (not percentages or dimensions), remove them and replace them with\n    // a single number containing the product of the removed nodes.\n    const [numbers, rest] = partition(children, (child) => child instanceof CSSUnitValue && child.unit === \"number\");\n    if (numbers.length > 1) {\n      const product = numbers.reduce((a, {value}) => a * value, 1);\n      children = [new CSSUnitValue(product, \"number\"), ...rest];\n    }\n\n    // If root contains only two children, one of which is a number (not a percentage or dimension) and the other of\n    // which is a Sum whose children are all numeric values, multiply all of the Sum’s children by the number,\n    // then return the Sum.\n    if (children.length === 2) {\n      let numeric, sum;\n      for (const child of children) {\n        if (child instanceof CSSUnitValue && child.unit === \"number\") {\n          numeric = child;\n        } else if (child instanceof CSSMathSum && [...child.values].every((c) => c instanceof CSSUnitValue)) {\n          sum = child;\n        }\n      }\n      if (numeric && sum) {\n        return new CSSMathSum(\n          ...[...sum.values].map((value) => new CSSUnitValue(value.value * numeric.value, value.unit)));\n      }\n    }\n\n    // If root contains only numeric values and/or Invert nodes containing numeric values, and multiplying the types of\n    // all the children (noting that the type of an Invert node is the inverse of its child’s type) results in a type\n    // that matches any of the types that a math function can resolve to, return the result of multiplying all the values\n    // of the children (noting that the value of an Invert node is the reciprocal of its child’s value),\n    // expressed in the result’s canonical unit.\n    if (children.every((child) => (child instanceof CSSUnitValue && isCanonical(child.unit)) ||\n      (child instanceof CSSMathInvert && child.value instanceof CSSUnitValue && isCanonical(child.value.unit)))) {\n      // Use CSS Typed OM to multiply types\n      const sum = new CSSMathProduct(...children).toSum();\n      if (sum && sum.values.length === 1) {\n        return sum.values[0];\n      }\n    }\n\n    // Return root.\n    return new CSSMathProduct(...children);\n  }\n  // Return root.\n  return root;\n}\n","import {\n  CommaToken,\n  DelimToken,\n  DimensionToken,\n  FunctionToken, IdentToken,\n  LeftCurlyBracketToken,\n  LeftParenthesisToken,\n  LeftSquareBracketToken,\n  NumberToken,\n  PercentageToken, RightCurlyBracketToken,\n  RightParenthesisToken, RightSquareBracketToken,\n  Token,\n  tokenizeString,\n  WhitespaceToken\n} from './tokenizer';\nimport {simplifyCalculation} from './simplify-calculation';\n\n/**\n * @typedef {{[string]: integer}} UnitMap\n * @typedef {[number, UnitMap]} SumValueItem\n * @typedef {SumValueItem[]} SumValue\n * @typedef {null} Failure\n * @typedef {{[string]: integer} & {percentHint: string | undefined}} Type\n * @typedef {{type: 'ADDITION'}|{type: 'MULTIPLICATION'}|{type: 'NEGATE'}|{type: 'INVERT'}} ASTNode\n */\n\nconst failure = null;\nconst baseTypes = [\"percent\", \"length\", \"angle\", \"time\", \"frequency\", \"resolution\", \"flex\"];\n\nconst unitGroups = {\n  // https://www.w3.org/TR/css-values-4/#font-relative-lengths\n  fontRelativeLengths: {\n    units: new Set([\"em\", \"rem\", \"ex\", \"rex\", \"cap\", \"rcap\", \"ch\", \"rch\", \"ic\", \"ric\", \"lh\", \"rlh\"])\n  },\n  // https://www.w3.org/TR/css-values-4/#viewport-relative-lengths\n  viewportRelativeLengths: {\n    units: new Set(\n      [\"vw\", \"lvw\", \"svw\", \"dvw\", \"vh\", \"lvh\", \"svh\", \"dvh\", \"vi\", \"lvi\", \"svi\", \"dvi\", \"vb\", \"lvb\", \"svb\", \"dvb\",\n        \"vmin\", \"lvmin\", \"svmin\", \"dvmin\", \"vmax\", \"lvmax\", \"svmax\", \"dvmax\"])\n  },\n  // https://www.w3.org/TR/css-values-4/#absolute-lengths\n  absoluteLengths: {\n    units: new Set([\"cm\", \"mm\", \"Q\", \"in\", \"pt\", \"pc\", \"px\"]),\n    compatible: true,\n    canonicalUnit: \"px\",\n    ratios: {\n      \"cm\": 96 / 2.54, \"mm\": (96 / 2.54) / 10, \"Q\": (96 / 2.54) / 40, \"in\": 96, \"pc\": 96 / 6, \"pt\": 96 / 72, \"px\": 1\n    }\n  },\n  // https://www.w3.org/TR/css-values-4/#angles\n  angle: {\n    units: new Set([\"deg\", \"grad\", \"rad\", \"turn\"]),\n    compatible: true,\n    canonicalUnit: \"deg\",\n    ratios: {\n      \"deg\": 1, \"grad\": 360 / 400, \"rad\": 180 / Math.PI, \"turn\": 360\n    }\n  },\n  // https://www.w3.org/TR/css-values-4/#time\n  time: {\n    units: new Set([\"s\", \"ms\"]),\n    compatible: true,\n    canonicalUnit: \"s\",\n    ratios: {\n      \"s\": 1, \"ms\": 1 / 1000\n    }\n  },\n  // https://www.w3.org/TR/css-values-4/#frequency\n  frequency: {\n    units: new Set([\"hz\", \"khz\"]),\n    compatible: true,\n    canonicalUnit: \"hz\",\n    ratios: {\n      \"hz\": 1, \"khz\": 1000\n    }\n  },\n  // https://www.w3.org/TR/css-values-4/#resolution\n  resolution: {\n    units: new Set([\"dpi\", \"dpcm\", \"dppx\"]),\n    compatible: true,\n    canonicalUnit: \"dppx\",\n    ratios: {\n      \"dpi\": 1 / 96, \"dpcm\": 2.54 / 96, \"dppx\": 1\n    }\n  }\n};\n\nconst unitToCompatibleUnitsMap = new Map();\nfor (const group of Object.values(unitGroups)) {\n  if (!group.compatible) {\n    continue;\n  }\n  for (const unit of group.units) {\n    unitToCompatibleUnitsMap.set(unit, group);\n  }\n}\n\nexport function getSetOfCompatibleUnits(unit) {\n  return unitToCompatibleUnitsMap.get(unit);\n}\n\n/**\n * Implementation of `product of two unit maps` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#product-of-two-unit-maps\n *\n * @param {UnitMap} units1 map of units (strings) to powers (integers)\n * @param {UnitMap} units2 map of units (strings) to powers (integers)\n * @return {UnitMap} map of units (strings) to powers (integers)\n */\nfunction productOfTwoUnitMaps(units1, units2) {\n  // 1. Let result be a copy of units1.\n  const result = {...units1};\n  // 2. For each unit → power in units2:\n  for (const unit of Object.keys(units2)) {\n    if (result[unit]) {\n      // 1. If result[unit] exists, increment result[unit] by power.\n      result[unit] += units2[unit];\n    } else {\n      // 2. Otherwise, set result[unit] to power.\n      result[unit] = units2[unit];\n    }\n  }\n  // 3. Return result.\n  return result;\n}\n\n/**\n * Implementation of `create a type` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#create-a-type\n *\n * @param {string} unit\n * @return {Type|Failure}\n */\nexport function createAType(unit) {\n  if (unit === \"number\") {\n    return {};\n  } else if (unit === \"percent\") {\n    return {\"percent\": 1};\n  } else if (unitGroups.absoluteLengths.units.has(unit) || unitGroups.fontRelativeLengths.units.has(unit) ||\n    unitGroups.viewportRelativeLengths.units.has(unit)) {\n    return {\"length\": 1};\n  } else if (unitGroups.angle.units.has(unit)) {\n    return {\"angle\": 1};\n  } else if (unitGroups.time.units.has(unit)) {\n    return {\"time\": 1};\n  } else if (unitGroups.frequency.units.has(unit)) {\n    return {\"frequency\": 1};\n  } else if (unitGroups.resolution.units.has(unit)) {\n    return {\"resolution\": 1};\n  } else if (unit === \"fr\") {\n    return {\"flex\": 1};\n  } else {\n    return failure;\n  }\n}\n\n/**\n * Partial implementation of `create a sum value` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#create-a-sum-value\n *\n * Supports CSSUnitValue, CSSMathProduct and CSSMathInvert with a CSSUnitValue value.\n * Other types are not supported, and will throw an error.\n *\n * @param {CSSNumericValue} cssNumericValue\n * @return {SumValue} Abstract representation of a CSSNumericValue as a sum of numbers with (possibly complex) units\n */\nexport function createSumValue(cssNumericValue) {\n  if (cssNumericValue instanceof CSSUnitValue) {\n    let {unit, value} = cssNumericValue;\n    // Let unit be the value of this’s unit internal slot, and value be the value of this’s value internal slot.\n    // If unit is a member of a set of compatible units, and is not the set’s canonical unit,\n    // multiply value by the conversion ratio between unit and the canonical unit, and change unit to the canonical unit.\n    const compatibleUnits = getSetOfCompatibleUnits(cssNumericValue.unit);\n    if (compatibleUnits && unit !== compatibleUnits.canonicalUnit) {\n      value *= compatibleUnits.ratios[unit];\n      unit = compatibleUnits.canonicalUnit;\n    }\n\n    if (unit === \"number\") {\n      // If unit is \"number\", return «(value, «[ ]»)».\n      return [[value, {}]];\n    } else {\n      // Otherwise, return «(value, «[unit → 1]»)».\n      return [[value, {[unit]: 1}]];\n    }\n  } else if (cssNumericValue instanceof CSSMathInvert) {\n    if (!(cssNumericValue.value instanceof CSSUnitValue)) {\n      // Limit implementation to CSSMathInvert of CSSUnitValue\n      throw new Error(\"Not implemented\");\n    }\n    // 1. Let values be the result of creating a sum value from this’s value internal slot.\n    const values = createSumValue(cssNumericValue.value);\n    // 2. If values is failure, return failure.\n    if (values === failure) {\n      return failure;\n    }\n    // 3. If the length of values is more than one, return failure.\n    if (values.length > 1) {\n      return failure;\n    }\n    // 4. Invert (find the reciprocal of) the value of the item in values, and negate the value of each entry in its unit map.\n    const item = values[0];\n    const tempUnionMap = {};\n    for (const [unit, power] of Object.entries(item[1])) {\n      tempUnionMap[unit] = -1 * power;\n    }\n    values[0] = [1 / item[0], tempUnionMap];\n\n    // 5. Return values.\n    return values;\n  } else if (cssNumericValue instanceof CSSMathProduct) {\n    // 1. Let values initially be the sum value «(1, «[ ]»)». (I.e. what you’d get from 1.)\n\n    let values = [[1, {}]];\n\n    // 2. For each item in this’s values internal slot:\n    for (const item of cssNumericValue.values) {\n      // 1. Let new values be the result of creating a sum value from item. Let temp initially be an empty list.\n      const newValues = createSumValue(item);\n      const temp = [];\n      // 2. If new values is failure, return failure.\n      if (newValues === failure) {\n        return failure;\n      }\n      // 3. For each item1 in values:\n      for (const item1 of values) {\n        // 1. For each item2 in new values:\n        for (const item2 of newValues) {\n          // 1. Let item be a tuple with its value set to the product of the values of item1 and item2, and its unit\n          //    map set to the product of the unit maps of item1 and item2, with all entries with a zero value removed.\n          // 2. Append item to temp.\n          temp.push([item1[0] * item2[0], productOfTwoUnitMaps(item1[1], item2[1])]);\n        }\n      }\n      // 4. Set values to temp.\n      values = temp;\n    }\n    // Return values.\n    return values;\n  } else {\n    throw new Error(\"Not implemented\");\n  }\n}\n\n\n/**\n * Implementation of `to(unit)` for CSSNumericValue from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#dom-cssnumericvalue-to\n *\n * Converts an existing CSSNumeric value into another with the specified unit, if possible.\n *\n * @param {CSSNumericValue} cssNumericValue value to convert\n * @param {string} unit\n * @return {CSSUnitValue}\n */\nexport function to(cssNumericValue, unit) {\n  // Let type be the result of creating a type from unit. If type is failure, throw a SyntaxError.\n  const type = createAType(unit);\n  if (type === failure) {\n    throw new SyntaxError(\"The string did not match the expected pattern.\");\n  }\n\n  // Let sum be the result of creating a sum value from this.\n  const sumValue = createSumValue(cssNumericValue);\n\n  // If sum is failure, throw a TypeError.\n  if (!sumValue) {\n    throw new TypeError();\n  }\n\n  // If sum has more than one item, throw a TypeError.\n  if (sumValue.length > 1) {\n    throw new TypeError(\"Sum has more than one item\");\n  }\n\n  // Otherwise, let item be the result of creating a CSSUnitValue\n  // from the sole item in sum, then converting it to unit.\n  const item = convertCSSUnitValue(createCSSUnitValue(sumValue[0]), unit);\n\n\n  // If item is failure, throw a TypeError.\n  if (item === failure) {\n    throw new TypeError();\n  }\n  // Return item.\n  return item;\n}\n\n/**\n * Implementation of `create a CSSUnitValue from a sum value item` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#create-a-cssunitvalue-from-a-sum-value-item\n *\n * @param {SumValueItem} sumValueItem  a tuple of a value, and a unit map\n * @return {CSSUnitValue|Failure}\n */\nexport function createCSSUnitValue(sumValueItem) {\n  const [value, unitMap] = sumValueItem;\n  // When asked to create a CSSUnitValue from a sum value item item, perform the following steps:\n  // If item has more than one entry in its unit map, return failure.\n  const entries = Object.entries(unitMap);\n  if (entries.length > 1) {\n    return failure;\n  }\n  // If item has no entries in its unit map, return a new CSSUnitValue whose unit internal slot is set to \"number\",\n  // and whose value internal slot is set to item’s value.\n  if (entries.length === 0) {\n    return new CSSUnitValue(value, \"number\");\n  }\n  // Otherwise, item has a single entry in its unit map. If that entry’s value is anything other than 1, return failure.\n  const entry = entries[0];\n  if (entry[1] !== 1) {\n    return failure;\n  }\n  // Otherwise, return a new CSSUnitValue whose unit internal slot is set to that entry’s key, and whose value internal slot is set to item’s value.\n  else {\n    return new CSSUnitValue(value, entry[0]);\n  }\n}\n\n/**\n * Implementation of `convert a CSSUnitValue` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#convert-a-cssunitvalue\n\n * @param {CSSUnitValue} cssUnitValue\n * @param {string} unit\n * @return {CSSUnitValue|Failure}\n */\nexport function convertCSSUnitValue(cssUnitValue, unit) {\n  // Let old unit be the value of this’s unit internal slot, and old value be the value of this’s value internal slot.\n  const oldUnit = cssUnitValue.unit;\n  const oldValue = cssUnitValue.value;\n  // If old unit and unit are not compatible units, return failure.\n  const oldCompatibleUnitGroup = getSetOfCompatibleUnits(oldUnit);\n  const compatibleUnitGroup = getSetOfCompatibleUnits(unit);\n  if (!compatibleUnitGroup || oldCompatibleUnitGroup !== compatibleUnitGroup) {\n    return failure;\n  }\n  // Return a new CSSUnitValue whose unit internal slot is set to unit, and whose value internal slot is set to\n  // old value multiplied by the conversation ratio between old unit and unit.\n  return new CSSUnitValue(oldValue * compatibleUnitGroup.ratios[oldUnit] / compatibleUnitGroup.ratios[unit], unit);\n}\n\n/**\n * Partial implementation of `toSum(...units)`:\n * https://www.w3.org/TR/css-typed-om-1/#dom-cssnumericvalue-tosum\n *\n * The implementation is restricted to conversion without units.\n * It simplifies a CSSNumericValue into a minimal sum of CSSUnitValues.\n * Will throw an error if called with units.\n *\n * @param {CSSNumericValue} cssNumericValue value to convert to a CSSMathSum\n * @param {string[]} units Not supported in this implementation\n * @return {CSSMathSum}\n */\nexport function toSum(cssNumericValue, ...units) {\n  // The toSum(...units) method converts an existing CSSNumericValue this into a CSSMathSum of only CSSUnitValues\n  // with the specified units, if possible. (It’s like to(), but allows the result to have multiple units in it.)\n  // If called without any units, it just simplifies this into a minimal sum of CSSUnitValues.\n  // When called, it must perform the following steps:\n  //\n  // For each unit in units, if the result of creating a type from unit is failure, throw a SyntaxError.\n  //\n  if (units && units.length) {\n    // Only unitless method calls are implemented in this polyfill\n    throw new Error(\"Not implemented\");\n  }\n\n  // Let sum be the result of creating a sum value from this. If sum is failure, throw a TypeError.\n  const sum = createSumValue(cssNumericValue);\n\n  // Let values be the result of creating a CSSUnitValue for each item in sum. If any item of values is failure,\n  // throw a TypeError.\n  const values = sum.map(item => createCSSUnitValue(item));\n  if (values.some(value => value === failure)) {\n    throw new TypeError(\"Type error\");\n  }\n\n  // If units is empty, sort values in code point order according to the unit internal slot of its items,\n  // then return a new CSSMathSum object whose values internal slot is set to values.\n  return new CSSMathSum(...values);\n}\n\n/**\n * Implementation of `invert a type` from css-typed-om-1 Editors Draft:\n * https://drafts.css-houdini.org/css-typed-om/\n *\n * @param {Type} type\n * @return {Type}\n */\nexport function invertType(type) {\n  // To invert a type type, perform the following steps:\n  // Let result be a new type with an initially empty ordered map and an initially null percent hint\n  // For each unit → exponent of type, set result[unit] to (-1 * exponent).\n  // Return result.\n  const result = {};\n  for (const baseType of baseTypes) {\n    result[baseType] = -1 * type[baseType];\n  }\n  return result;\n}\n\n/**\n * Implementation of `multiply two types` from css-typed-om-1 Editor's Draft:\n * https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-multiply-two-types\n *\n * @param {Type} type1 a map of base types to integers and an associated percent hint\n * @param {Type} type2 a map of base types to integers and an associated percent hint\n * @return {Type|Failure}\n */\nexport function multiplyTypes(type1, type2) {\n  if (type1.percentHint && type2.percentHint && type1.percentHint !== type2.percentHint) {\n    return failure;\n  }\n  const finalType = {\n    ...type1, percentHint: type1.percentHint ?? type2.percentHint,\n  };\n\n  for (const baseType of baseTypes) {\n    if (!type2[baseType]) {\n      continue;\n    }\n    finalType[baseType] ??= 0;\n    finalType[baseType] += type2[baseType];\n  }\n  return finalType;\n}\n\nclass CSSFunction {\n  name;\n  values;\n  constructor(name, values) {\n    this.name = name;\n    this.values = values;\n  }\n}\n\nclass CSSSimpleBlock {\n  value;\n  associatedToken;\n  constructor(value, associatedToken) {\n    this.value = value;\n    this.associatedToken = associatedToken;\n  }\n}\n\n/**\n * Normalize into a token stream\n * https://www.w3.org/TR/css-syntax-3/#normalize-into-a-token-stream\n */\nfunction normalizeIntoTokenStream(input) {\n  // If input is a list of CSS tokens, return input.\n  // If input is a list of CSS component values, return input.\n  if (Array.isArray(input)) {\n    return input;\n  }\n  // If input is a string, then filter code points from input, tokenize the result, and return the final result.\n  if (typeof input === 'string') {\n    return tokenizeString(input);\n  }\n  // Assert: Only the preceding types should be passed as input.\n  throw new TypeError(`Invalid input type ${typeof input}`)\n}\n\n/**\n * Consume a function\n * https://www.w3.org/TR/css-syntax-3/#consume-a-function\n * @param {FunctionToken} token\n * @param {Token[]} tokens\n */\nfunction consumeFunction(token, tokens) {\n  // Create a function with its name equal to the value of the current input token and with its value initially set to an empty list.\n  const func = new CSSFunction(token.value, []);\n\n  // Repeatedly consume the next input token and process it as follows:\n  while(true) {\n    const nextToken = tokens.shift();\n    if (nextToken instanceof RightParenthesisToken) {\n      // <)-token>\n      // Return the function.\n      return func;\n    } else if (typeof nextToken === 'undefined') {\n      // <EOF-token>\n      // This is a parse error. Return the function.\n      return func;\n    } else {\n      // anything else\n      // Reconsume the current input token. Consume a component value and append the returned value to the function’s value.\n      tokens.unshift(nextToken);\n      func.values.push(consumeComponentValue(tokens));\n    }\n  }\n}\n\n/**\n * Consume a simple block\n * https://www.w3.org/TR/css-syntax-3/#consume-simple-block\n * @param {Token[]} tokens\n * @param {LeftCurlyBracketToken | LeftParenthesisToken | LeftSquareBracketToken} currentInputToken\n */\nfunction consumeSimpleBlock(tokens, currentInputToken) {\n  // The ending token is the mirror variant of the current input token. (E.g. if it was called with <[-token>, the ending token is <]-token>.)\n  let endingTokenConstructor ;\n  if (currentInputToken instanceof LeftCurlyBracketToken) {\n    endingTokenConstructor = RightCurlyBracketToken;\n  } else if (currentInputToken instanceof LeftParenthesisToken) {\n    endingTokenConstructor = RightParenthesisToken;\n  } else if (currentInputToken instanceof LeftSquareBracketToken) {\n    endingTokenConstructor = RightSquareBracketToken;\n  } else {\n    return undefined;\n  }\n\n\n  // Create a simple block with its associated token set to the current input token and with its value initially set to an empty list.\n  const simpleBlock = new CSSSimpleBlock([], currentInputToken);\n\n  // Repeatedly consume the next input token and process it as follows:\n  while (true) {\n    const token = tokens.shift();\n    if (token instanceof endingTokenConstructor) {\n      // ending token\n      // Return the block.\n      return simpleBlock;\n    } else if (typeof token === 'undefined') {\n      // <EOF-token>\n      // This is a parse error. Return the block.\n      return simpleBlock;\n    } else {\n      // anything else\n      // Reconsume the current input token. Consume a component value and append it to the value of the block.\n      tokens.unshift(token);\n      simpleBlock.value.push(consumeComponentValue(tokens));\n    }\n  }\n}\n\n/**\n * Consume a component value\n * https://www.w3.org/TR/css-syntax-3/#consume-a-component-value\n * @param {Token[]} tokens\n */\nfunction consumeComponentValue(tokens) {\n  const syntaxError = null;\n  // Consume the next input token.\n  const token = tokens.shift();\n\n  if (token instanceof LeftCurlyBracketToken || token instanceof LeftSquareBracketToken || token instanceof LeftParenthesisToken) {\n    // If the current input token is a <{-token>, <[-token>, or <(-token>, consume a simple block and return it.\n    return consumeSimpleBlock(tokens, token);\n  } else if (token instanceof FunctionToken) {\n    // Otherwise, if the current input token is a <function-token>, consume a function and return it.\n    return consumeFunction(token, tokens);\n  } else {\n    // Otherwise, return the current input token.\n    return token;\n  }\n}\n\n/**\n * Parse a component value\n * https://www.w3.org/TR/css-syntax-3/#parse-component-value\n * @param {string} input\n */\nfunction parseComponentValue(input) {\n  const syntaxError = null;\n  // To parse a component value from input:\n  // 1. Normalize input, and set input to the result.\n  const tokens = normalizeIntoTokenStream(input);\n\n  // 2. While the next input token from input is a <whitespace-token>, consume the next input token from input.\n  while (tokens[0] instanceof WhitespaceToken) {\n    tokens.shift();\n  }\n  // 3. If the next input token from input is an <EOF-token>, return a syntax error.\n  if (typeof tokens[0] === 'undefined') {\n    return syntaxError;\n  }\n  // 4. Consume a component value from input and let value be the return value.\n  const returnValue = consumeComponentValue(tokens);\n  // 5. While the next input token from input is a <whitespace-token>, consume the next input token.\n  while (tokens[0] instanceof WhitespaceToken) {\n    tokens.shift();\n  }\n  // 6. If the next input token from input is an <EOF-token>, return value. Otherwise, return a syntax error.\n  if (typeof tokens[0] === 'undefined') {\n    return returnValue;\n  } else {\n    return syntaxError;\n  }\n}\n\nfunction precedence(token) {\n  if (token instanceof LeftParenthesisToken || token instanceof RightParenthesisToken) {\n    return 6;\n  } else if (token instanceof DelimToken) {\n    const value = token.value;\n    switch (value) {\n      case '*':\n        return 4;\n      case '/':\n        return 4;\n      case '+':\n        return 2;\n      case '-':\n        return 2;\n    }\n  }\n}\n\n\nfunction last(items) {\n  return items[items.length - 1];\n}\n\nfunction toNAryAstNode(operatorToken, first, second) {\n  // Treat subtraction as instead being addition, with the RHS argument instead wrapped in a special \"negate\" node.\n  // Treat division as instead being multiplication, with the RHS argument instead wrapped in a special \"invert\" node.\n\n  const type = ['+','-'].includes(operatorToken.value) ? 'ADDITION' : 'MULTIPLICATION';\n  const firstValues = first.type === type ? first.values : [first];\n  const secondValues = second.type === type ? second.values : [second];\n\n  if (operatorToken.value === '-') {\n    secondValues[0] = {type: 'NEGATE', value: secondValues[0]};\n  } else if (operatorToken.value   === '/') {\n    secondValues[0] = {type: 'INVERT', value: secondValues[0]};\n  }\n  return {type, values: [...firstValues, ...secondValues]};\n}\n\n/**\n * Convert expression to AST using the Shunting Yard Algorithm\n * https://en.wikipedia.org/wiki/Shunting_yard_algorithm\n * @param {(Token | CSSFunction)[]} tokens\n * @return {null}\n */\nfunction convertTokensToAST(tokens) {\n  const operatorStack = [];\n  const tree = [];\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (token instanceof NumberToken || token instanceof DimensionToken || token instanceof PercentageToken ||\n      token instanceof CSSFunction || token instanceof CSSSimpleBlock || token instanceof IdentToken) {\n      tree.push(token);\n    } else if (token instanceof DelimToken && ['*', '/', '+', '-'].includes(token.value)) {\n      while (operatorStack.length &&\n      !(last(operatorStack) instanceof LeftParenthesisToken) &&\n      precedence(last(operatorStack)) > precedence(token)) {\n        const o2 = operatorStack.pop();\n        const second = tree.pop();\n        const first = tree.pop();\n        tree.push(toNAryAstNode(o2, first, second));\n      }\n      operatorStack.push(token);\n    } else if (token instanceof LeftParenthesisToken) {\n      operatorStack.push(token);\n    } else if (token instanceof RightParenthesisToken) {\n      if (!operatorStack.length) {\n        return null;\n      }\n      while (!(last(operatorStack) instanceof LeftParenthesisToken) ) {\n        const o2 = operatorStack.pop();\n        const second = tree.pop();\n        const first = tree.pop();\n        tree.push(toNAryAstNode(o2, first, second));\n      }\n      if (!(last(operatorStack) instanceof LeftParenthesisToken)) {\n        return null;\n      }\n      operatorStack.pop();\n    } else if (token instanceof WhitespaceToken) {\n      // Consume token\n    } else {\n      return null;\n    }\n  }\n  while(operatorStack.length) {\n    if (last(operatorStack) instanceof LeftParenthesisToken) {\n      return null;\n    }\n    const o2 = operatorStack.pop()\n    const second = tree.pop();\n    const first = tree.pop();\n    tree.push(toNAryAstNode(o2, first, second));\n  }\n  return tree[0];\n}\n\n/**\n * Step 4 of `reify a math expression`\n * https://drafts.css-houdini.org/css-typed-om/#reify-a-math-expression\n *\n * 4. Recursively transform the expression tree into objects, as follows:\n *\n * @param {ASTNode} node\n * @return {CSSMathNegate|CSSMathProduct|CSSMathMin|CSSMathMax|CSSMathSum|CSSNumericValue|CSSUnitValue|CSSMathInvert}\n */\nfunction transformToCSSNumericValue(node) {\n  if (node.type === 'ADDITION') {\n    // addition node\n    // becomes a new CSSMathSum object, with its values internal slot set to its list of arguments\n    return new CSSMathSum(...node.values.map(value => transformToCSSNumericValue(value)));\n  } else if (node.type === 'MULTIPLICATION') {\n    // multiplication node\n    // becomes a new CSSMathProduct object, with its values internal slot set to its list of arguments\n    return new CSSMathProduct(...node.values.map(value => transformToCSSNumericValue(value)));\n  } else  if (node.type === 'NEGATE') {\n    // negate node\n    // becomes a new CSSMathNegate object, with its value internal slot set to its argument\n    return new CSSMathNegate(transformToCSSNumericValue(node.value));\n  } else if (node.type === 'INVERT') {\n    // invert node\n    // becomes a new CSSMathInvert object, with its value internal slot set to its argument\n    return new CSSMathInvert(transformToCSSNumericValue(node.value));\n  } else {\n    // leaf node\n    // reified as appropriate\n    if (node instanceof CSSSimpleBlock) {\n      return reifyMathExpression(new CSSFunction('calc', node.value));\n    } else if (node instanceof IdentToken) {\n      if (node.value === 'e') {\n        return new CSSUnitValue(Math.E, 'number');\n      } else if (node.value === 'pi') {\n        return new CSSUnitValue(Math.PI, 'number');\n      } else {\n        throw new SyntaxError('Invalid math expression')\n      }\n    } else {\n      return reifyNumericValue(node);\n    }\n  }\n}\n\n/**\n * Reify a math expression\n * https://drafts.css-houdini.org/css-typed-om/#reify-a-math-expression\n * @param {CSSFunction} num\n */\nfunction reifyMathExpression(num) {\n  // TODO: handle `clamp()` and possibly other math functions\n  // 1. If num is a min() or max() expression:\n  if (num.name === 'min' || num.name === 'max')\n  {\n    // Let values be the result of reifying the arguments to the expression, treating each argument as if it were the contents of a calc() expression.\n    const values = num.values\n      .filter(value => !(value instanceof WhitespaceToken || value instanceof CommaToken))\n      // TODO: Update when we have clarification on where simplify a calculation should be run:\n      // https://github.com/w3c/csswg-drafts/issues/9870\n      .map(value => simplifyCalculation(reifyMathExpression(new CSSFunction('calc', value))));\n    // Return a new CSSMathMin or CSSMathMax object, respectively, with its values internal slot set to values.\n    return num.name === 'min' ? new CSSMathMin(...values) : new CSSMathMax(...values);\n  }\n\n  // 2. Assert: Otherwise, num is a calc().\n  if (num.name !== 'calc') {\n    return null;\n  }\n\n  // 3. Turn num’s argument into an expression tree using standard PEMDAS precedence rules, with the following exceptions/clarification:\n  //\n  // Treat subtraction as instead being addition, with the RHS argument instead wrapped in a special \"negate\" node.\n  // Treat division as instead being multiplication, with the RHS argument instead wrapped in a special \"invert\" node.\n  // Addition and multiplication are N-ary; each node can have any number of arguments.\n  // If an expression has only a single value in it, and no operation, treat it as an addition node with the single argument.\n  const root = convertTokensToAST([...num.values]);\n  \n  // 4. Recursively transform the expression tree into objects\n  const numericValue = transformToCSSNumericValue(root);\n  let simplifiedValue;\n  try {\n    // TODO: Update when we have clarification on where simplify a calculation should be run:\n    // https://github.com/w3c/csswg-drafts/issues/9870\n    simplifiedValue = simplifyCalculation(numericValue);\n  } catch (e) {\n    // Use insertRule to trigger native SyntaxError on TypeError\n    (new CSSStyleSheet()).insertRule('error', 0);\n  }\n  if (simplifiedValue instanceof CSSUnitValue) {\n    return new CSSMathSum(simplifiedValue);\n  } else {\n    return simplifiedValue;\n  }\n}\n\n/**\n * Reify a numeric value\n * https://drafts.css-houdini.org/css-typed-om/#reify-a-numeric-value\n * @param num\n */\nfunction reifyNumericValue(num) {\n  // If an internal representation contains a var() reference, then it is reified by reifying a list of component values,\n  // regardless of what property it is for.\n  // TODO: handle `var()` function\n\n  // If num is a math function, reify a math expression from num and return the result.\n  if (num instanceof CSSFunction && ['calc', 'min', 'max', 'clamp'].includes(num.name)) {\n    return reifyMathExpression(num);\n  }\n  // If num is the unitless value 0 and num is a <dimension>,\n  // return a new CSSUnitValue with its value internal slot set to 0, and its unit internal slot set to \"px\".\n  if (num instanceof NumberToken && num.value === 0 && !num.unit) {\n    return new CSSUnitValue(0, 'px');\n  }\n  // Return a new CSSUnitValue with its value internal slot set to the numeric value of num, and its unit internal slot\n  // set to \"number\" if num is a <number>, \"percent\" if num is a <percentage>, and num’s unit if num is a <dimension>.\n  if (num instanceof NumberToken) {\n    return new CSSUnitValue(num.value, 'number');\n  } else if (num instanceof PercentageToken) {\n    return new CSSUnitValue(num.value, 'percent');\n  } else if (num instanceof DimensionToken) {\n    return new CSSUnitValue(num.value, num.unit);\n  }\n}\n\n/**\n * Implementation of the parse(cssText) method.\n * https://drafts.css-houdini.org/css-typed-om-1/#dom-cssnumericvalue-parse\n * @param {string} cssText\n * @return {CSSMathMin|CSSMathMax|CSSMathSum|CSSMathProduct|CSSMathNegate|CSSMathInvert|CSSUnitValue}\n */\nexport function parseCSSNumericValue(cssText) {\n  // Parse a component value from cssText and let result be the result.\n  // If result is a syntax error, throw a SyntaxError and abort this algorithm.\n  const result = parseComponentValue(cssText);\n  if (result === null) {\n    // Use insertRule to trigger native SyntaxError\n    (new CSSStyleSheet()).insertRule('error', 0);\n  }\n  // If result is not a <number-token>, <percentage-token>, <dimension-token>, or a math function, throw a SyntaxError and abort this algorithm.\n  if (!(result instanceof NumberToken || result instanceof PercentageToken || result instanceof DimensionToken || result instanceof CSSFunction)) {\n    // Use insertRule to trigger native SyntaxError\n    (new CSSStyleSheet()).insertRule('error', 0);\n  }\n  // If result is a <dimension-token> and creating a type from result’s unit returns failure, throw a SyntaxError and abort this algorithm.\n  if (result instanceof DimensionToken) {\n    const type = createAType(result.unit);\n    if (type === null) {\n      // Use insertRule to trigger native SyntaxError\n      (new CSSStyleSheet()).insertRule('error', 0);\n    }\n  }\n  // Reify a numeric value result, and return the result.\n  return reifyNumericValue(result);\n}","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport {createAType, invertType, multiplyTypes, parseCSSNumericValue, to, toSum} from './numeric-values';\nimport {simplifyCalculation} from './simplify-calculation';\nimport './tokenizer'\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  function displayUnit(unit) {\n    switch(unit) {\n      case 'percent':\n        return '%';\n      case 'number':\n        return '';\n      default:\n        return unit.toLowerCase();\n    }\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class CSSNumericValue {\n    static parse(value) {\n      if (value instanceof CSSNumericValue) return value;\n\n      return simplifyCalculation(parseCSSNumericValue(value), {});\n    }\n\n    // TODO: Add other methods: add, sub, mul, div, …\n    // Spec: https://drafts.css-houdini.org/css-typed-om/#numeric-value\n  }\n\n  class CSSMathValue extends CSSNumericValue {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      super();\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  const cssOMTypes = {\n    'CSSNumericValue': CSSNumericValue,\n    'CSSMathValue': CSSMathValue,\n    'CSSUnitValue': class extends CSSNumericValue {\n      constructor(value, unit) {\n        super();\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      to(unit) {\n        return to(this, unit)\n      }\n\n      toSum(...units) {\n        return toSum(this, ...units)\n      }\n\n      type() {\n        const details = privateDetails.get(this)\n        // The type of a CSSUnitValue is the result of creating a type from its unit internal slot.\n        return createAType(details.unit)\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    },\n\n    'CSSKeywordValue': class {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    },\n\n    'CSSMathSum': class extends CSSMathValue  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    },\n\n    'CSSMathProduct': class extends CSSMathValue  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n\n      toSum(...units) {\n        return toSum(this, ...units)\n      }\n\n      type() {\n        const values = privateDetails.get(this).values;\n        // The type is the result of multiplying the types of each of the items in its values internal slot.\n        return values.map(v => v.type()).reduce(multiplyTypes)\n      }\n    },\n\n    'CSSMathNegate': class extends CSSMathValue {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n\n      get value() {\n        return  privateDetails.get(this).values[0];\n      }\n\n      type() {\n        return this.value.type();\n      }\n    },\n\n    'CSSMathInvert': class extends CSSMathValue {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n\n      get value() {\n        return  privateDetails.get(this).values[1];\n      }\n\n      type() {\n        const details = privateDetails.get(this)\n        // The type of a CSSUnitValue is the result of creating a type from its unit internal slot.\n        return invertType(details.values[1].type())\n      }\n    },\n\n    'CSSMathMax': class extends CSSMathValue {\n      constructor() {\n        super(arguments, 'max');\n      }\n    },\n\n    'CSSMathMin': class extends CSSMathValue  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n  };\n\n  if (!window.CSS) {\n    if (!Reflect.defineProperty(window, 'CSS', { value: {} }))\n      throw Error(`Error installing CSSOM support`);\n  }\n\n  if (!window.CSSUnitValue) {\n    [\n      'number',\n      'percent',\n      // Length units\n      'em',\n      'ex',\n      'px',\n      'cm',\n      'mm',\n      'in',\n      'pt',\n      'pc',  // Picas\n      'Q',  // Quarter millimeter\n      'vw',\n      'vh',\n      'vmin',\n      'vmax',\n      'rems',\n      \"ch\",\n      // Angle units\n      'deg',\n      'rad',\n      'grad',\n      'turn',\n      // Time units\n      'ms',\n      's',\n      'Hz',\n      'kHz',\n      // Resolution\n      'dppx',\n      'dpi',\n      'dpcm',\n      // Other units\n      \"fr\"\n    ].forEach((name) => {\n      const fn = (value) => {\n        return new CSSUnitValue(value, name);\n      };\n      if (!Reflect.defineProperty(CSS, name, { value: fn }))\n        throw Error(`Error installing CSS.${name}`);\n    });\n  }\n\n  for (let [type, value] of Object.entries(cssOMTypes)) {\n    if (type in window)\n      continue;\n    if (!Reflect.defineProperty(window, type, { value }))\n      throw Error(`Error installing CSSOM support for ${type}`);\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {installCSSOM} from \"./proxy-cssom.js\";\nimport {simplifyCalculation} from \"./simplify-calculation\";\nimport {normalizeAxis, splitIntoComponentValues} from './utils.js';\n\ninstallCSSOM();\n\nconst DEFAULT_TIMELINE_AXIS = 'block';\n\nlet scrollTimelineOptions = new WeakMap();\nlet sourceDetails = new WeakMap();\n\nexport const ANIMATION_RANGE_NAMES = ['entry', 'exit', 'cover', 'contain', 'entry-crossing', 'exit-crossing'];\n\nfunction scrollEventSource(source) {\n  if (source === document.scrollingElement) return document;\n  return source;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  validateSource(scrollTimelineInstance);\n  const details = scrollTimelineOptions.get(scrollTimelineInstance);\n  let animations = details.animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical axis.\n * @param scrollTimeline {ScrollTimeline}\n * @param axis {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(source, axis) {\n  if (!source)\n    return null;\n  const sourceMeasurements = sourceDetails.get(source).sourceMeasurements;\n  const style = getComputedStyle(source);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  let currentScrollOffset = sourceMeasurements.scrollTop;\n  if (normalizeAxis(axis, style) === 'x') {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(sourceMeasurements.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Calculates scroll offset based on axis and source geometry\n * @param source {DOMElement}\n * @param axis {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(source, axis) {\n  const sourceMeasurements = sourceDetails.get(source).sourceMeasurements;\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(source).writingMode == 'horizontal-tb';\n  if (axis === \"block\")\n    axis = horizontalWritingMode ? \"y\" : \"x\";\n  else if (axis === \"inline\")\n    axis = horizontalWritingMode ? \"x\" : \"y\";\n  if (axis === \"y\")\n    return sourceMeasurements.scrollHeight - sourceMeasurements.clientHeight;\n  else if (axis === \"x\")\n    return sourceMeasurements.scrollWidth - sourceMeasurements.clientWidth;\n}\n\nfunction resolvePx(cssValue, info) {\n  const cssNumericValue = simplifyCalculation(cssValue, info);\n  if (cssNumericValue instanceof CSSUnitValue) {\n    if (cssNumericValue.unit === 'px') {\n      return cssNumericValue.value;\n    } else {\n      throw TypeError(\"Unhandled unit type \" + cssNumericValue.unit);\n    }\n  } else {\n    throw TypeError('Unsupported value type: ' + typeof (cssValue));\n  }\n}\n\n// Detects if the cached source is obsolete, and updates if required\n// to ensure the new source has a scroll listener.\nfunction validateSource(timeline) {\n  if (!(timeline instanceof ViewTimeline)) {\n    validateAnonymousSource(timeline);\n    return;\n  }\n\n  const node = timeline.subject;\n  if (!node) {\n    updateSource(timeline, null);\n    return;\n  }\n\n  const display  = getComputedStyle(node).display;\n  if (display == 'none') {\n    updateSource(timeline, null);\n    return;\n  }\n\n  const source = getScrollParent(node);\n  updateSource(timeline, source);\n}\n\nfunction validateAnonymousSource(timeline) {\n  const details = scrollTimelineOptions.get(timeline);\n  if(!details.anonymousSource)\n    return;\n\n  const source = getAnonymousSourceElement(details.anonymousSource, details.anonymousTarget);\n  updateSource(timeline, source);\n}\n\nfunction isValidAxis(axis) {\n  return [\"block\", \"inline\", \"x\", \"y\"].includes(axis);\n}\n\n/**\n * Read measurements of source element\n * @param {HTMLElement} source\n * @return {{clientWidth: *, scrollHeight: *, scrollLeft, clientHeight: *, scrollTop, scrollWidth: *}}\n */\nexport function measureSource (source) {\n  const style = getComputedStyle(source);\n  return {\n    scrollLeft: source.scrollLeft,\n    scrollTop: source.scrollTop,\n    scrollWidth: source.scrollWidth,\n    scrollHeight: source.scrollHeight,\n    clientWidth: source.clientWidth,\n    clientHeight: source.clientHeight,\n    writingMode: style.writingMode,\n    direction: style.direction,\n    scrollPaddingTop: style.scrollPaddingTop,\n    scrollPaddingBottom: style.scrollPaddingBottom,\n    scrollPaddingLeft: style.scrollPaddingLeft,\n    scrollPaddingRight: style.scrollPaddingRight\n  };\n}\n\n/**\n * Measure subject element relative to source\n * @param {HTMLElement} source\n * @param {HTMLElement|undefined} subject\n * @param subject\n */\nexport function measureSubject(source, subject) {\n  if (!source || !subject) {\n    return\n  }\n  let top = 0;\n  let left = 0;\n  let node = subject;\n  const ancestor = source.offsetParent;\n  while (node && node != ancestor) {\n    left += node.offsetLeft;\n    top += node.offsetTop;\n    node = node.offsetParent;\n  }\n  left -= source.offsetLeft + source.clientLeft;\n  top -= source.offsetTop + source.clientTop;\n  const style = getComputedStyle(subject);\n  return {\n    top,\n    left,\n    offsetWidth: subject.offsetWidth,\n    offsetHeight: subject.offsetHeight,\n    fontSize: style.fontSize,\n  };\n}\n\n/**\n * Update measurements of source, and update timelines\n * @param {HTMLElement} source\n */\nfunction updateMeasurements(source) {\n  let details = sourceDetails.get(source);\n  details.sourceMeasurements = measureSource(source);\n\n  // Update measurements of the subject of connected view timelines\n  for (const ref of details.timelineRefs) {\n    const timeline = ref.deref();\n    if ((timeline instanceof ViewTimeline)) {\n      const timelineDetails = scrollTimelineOptions.get(timeline)\n      timelineDetails.subjectMeasurements = measureSubject(source, timeline.subject)\n    }\n  }\n\n  if (details.updateScheduled)\n    return;\n\n  setTimeout(() => {\n    // Schedule a task to update timelines after all measurements are completed\n    for (const ref of details.timelineRefs) {\n      const timeline = ref.deref();\n      if (timeline) {\n        updateInternal(timeline);\n      }\n    }\n\n    details.updateScheduled = false;\n  });\n  details.updateScheduled = true;\n}\n\nfunction updateSource(timeline, source) {\n  const timelineDetails = scrollTimelineOptions.get(timeline);\n  const oldSource = timelineDetails.source;\n  if (oldSource == source)\n    return;\n\n  if (oldSource) {\n    const details = sourceDetails.get(oldSource);\n    if (details) {\n      // Remove timeline reference from old source\n      details.timelineRefs.delete(timeline);\n\n      // Clean up timeline refs that have been garbage-collected\n      const undefinedRefs = Array.from(details.timelineRefs).filter(ref => typeof ref.deref() === 'undefined');\n      for (const ref of undefinedRefs) {\n        details.timelineRefs.delete(ref);\n      }\n\n      if (details.timelineRefs.size === 0) {\n        // All timelines have been disconnected from the source\n        // Clean up\n        details.disconnect();\n        sourceDetails.delete(oldSource);\n      }\n    }\n  }\n  timelineDetails.source = source;\n  if (source) {\n    let details = sourceDetails.get(source);\n    if (!details) {\n      // This is the first timeline for this source\n      // Store a set of weak refs to connected timelines and current measurements\n      details = {\n        timelineRefs: new Set(),\n        sourceMeasurements: measureSource(source)\n      };\n      sourceDetails.set(source, details);\n\n      // Use resize observer to detect changes to source size\n      const resizeObserver = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          updateMeasurements(timelineDetails.source)\n        }\n      });\n      resizeObserver.observe(source);\n      for (const child of source.children) {\n        resizeObserver.observe(child)\n      }\n\n      // Use mutation observer to detect updated style attributes on source element\n      const mutationObserver = new MutationObserver((records) => {\n        for (const record of records) {\n          updateMeasurements(record.target);\n        }\n      });\n      mutationObserver.observe(source, {attributes: true, attributeFilter: ['style', 'class']});\n\n      const scrollListener = () => {\n        // Sample and store scroll pos\n        details.sourceMeasurements.scrollLeft = source.scrollLeft;\n        details.sourceMeasurements.scrollTop = source.scrollTop;\n\n        for (const ref of details.timelineRefs) {\n          const timeline = ref.deref();\n          if (timeline) {\n            updateInternal(timeline);\n          }\n        }\n      };\n      scrollEventSource(source).addEventListener(\"scroll\", scrollListener);\n      details.disconnect = () => {\n        resizeObserver.disconnect();\n        mutationObserver.disconnect();\n        scrollEventSource(source).removeEventListener(\"scroll\", scrollListener);\n      };\n    }\n\n    // Add a weak ref to the timeline so that we can update it when the source changes\n    details.timelineRefs.add(new WeakRef(timeline));\n  }\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    // @TODO: This early return causes issues when a page with the polyfill\n    // is loaded from the BFCache. Ideally, this code gets fixed instead of\n    // the workaround which clears the proxyAnimations cache on pagehide.\n    // See https://github.com/flackr/scroll-timeline/issues/146#issuecomment-1698159183\n    // for details.\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  queueMicrotask(() => {\n    updateInternal(scrollTimeline);\n  });\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      source: null,\n      axis: DEFAULT_TIMELINE_AXIS,\n      anonymousSource: (options ? options.anonymousSource : null),\n      anonymousTarget: (options ? options.anonymousTarget : null),\n\n      // View timeline\n      subject: null,\n      inset: null,\n\n      // Internal members\n      animations: [],\n      subjectMeasurements: null\n    });\n    const source =\n      options && options.source !== undefined ? options.source\n                                              : document.scrollingElement;\n    updateSource(this, source);\n\n    if ((options && options.axis !== undefined) &&\n        (options.axis != DEFAULT_TIMELINE_AXIS)) {\n      if (!isValidAxis(options.axis)) {\n        throw TypeError(\"Invalid axis\");\n      }\n\n      scrollTimelineOptions.get(this).axis = options.axis;\n    }\n\n    updateInternal(this);\n  }\n\n  set source(element) {\n    updateSource(this, element);\n    updateInternal(this);\n  }\n\n  get source() {\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set axis(axis) {\n    if (!isValidAxis(axis)) {\n      throw TypeError(\"Invalid axis\");\n    }\n\n    scrollTimelineOptions.get(this).axis = axis;\n    updateInternal(this);\n  }\n\n  get axis() {\n    return scrollTimelineOptions.get(this).axis;\n  }\n\n  get duration() {\n    return CSS.percent(100);\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    const unresolved = null;\n    //   if source is null\n    const container = this.source;\n    if (!container) return \"inactive\";\n    let scrollerStyle = getComputedStyle(container);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (container != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    return \"active\"\n  }\n\n  get currentTime() {\n    const unresolved = null;\n    const container = this.source;\n    if (!container || !container.isConnected) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n    const scrollerStyle = getComputedStyle(container);\n    if (\n      scrollerStyle.display === \"inline\" ||\n      scrollerStyle.display === \"none\"\n    ) {\n      return unresolved;\n    }\n\n    const axis = this.axis;\n    const scrollPos = directionAwareScrollOffset(container, axis);\n    const maxScrollPos = calculateMaxScrollOffset(container, axis);\n\n    return maxScrollPos > 0 ? CSS.percent(100 * scrollPos / maxScrollPos)\n                            : CSS.percent(100);\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n\n// Methods for calculation of the containing block.\n// See https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block.\n\nfunction findClosestAncestor(element, matcher) {\n  let candidate = element.parentElement;\n  while(candidate != null) {\n    if (matcher(candidate))\n      return candidate;\n    candidate = candidate.parentElement;\n  }\n}\n\nexport function getAnonymousSourceElement(sourceType, node) {\n  switch (sourceType) {\n    case 'root':\n      return document.scrollingElement;\n    case 'nearest':\n      return getScrollParent(node);\n    case 'self':\n      return node;\n    default:\n      throw new TypeError('Invalid ScrollTimeline Source Type.');\n  }\n}\n\nfunction isBlockContainer(element) {\n  const style = getComputedStyle(element);\n  switch (style.display) {\n    case 'block':\n    case 'inline-block':\n    case 'list-item':\n    case 'table':\n    case 'table-caption':\n    case 'flow-root':\n    case 'flex':\n    case 'grid':\n      return true;\n  }\n\n  return false;\n}\n\nfunction isFixedElementContainer(element) {\n  const style = getComputedStyle(element);\n  if (style.transform != 'none' || style.perspective != 'none')\n    return true;\n\n  if (style.willChange == 'transform' || style.willChange == 'perspective')\n    return true;\n\n  if (style.filter != 'none' || style.willChange == 'filter')\n    return true;\n\n  if (style.backdropFilter != 'none')\n    return true;\n\n  return false;\n}\n\nfunction isAbsoluteElementContainer(element) {\n  const style = getComputedStyle(element);\n  if (style.position != 'static')\n    return true;\n\n  return isFixedElementContainer(element);\n}\n\nfunction getContainingBlock(element) {\n  switch (getComputedStyle(element).position) {\n    case 'static':\n    case 'relative':\n    case 'sticky':\n      return findClosestAncestor(element, isBlockContainer);\n\n    case 'absolute':\n      return findClosestAncestor(element, isAbsoluteElementContainer);\n\n    case 'fixed':\n      return findClosestAncestor(element, isFixedElementContainer);\n  }\n}\n\nexport function getScrollParent(node) {\n  if (!node || !node.isConnected)\n    return undefined;\n\n  while (node = getContainingBlock(node)) {\n    const style = getComputedStyle(node);\n    switch(style['overflow-x']) {\n      case 'auto':\n      case 'scroll':\n      case 'hidden':\n        // https://drafts.csswg.org/css-overflow-3/#overflow-propagation\n        // The UA must apply the overflow from the root element to the viewport;\n        // however, if the overflow is visible in both axis, then the overflow\n        // of the first visible child body is applied instead.\n        if (node == document.body &&\n            getComputedStyle(document.scrollingElement).overflow == \"visible\")\n          return  document.scrollingElement;\n\n        return node;\n    }\n  }\n  return document.scrollingElement;\n}\n\n// ---- View timelines -----\n\n// Computes the scroll offsets corresponding to the [0, 100]% range for a\n// specific phase on a view timeline.\n// TODO: Track changes to determine when associated animations require their\n// timing to be renormalized.\nexport function range(timeline, phase) {\n  const details = scrollTimelineOptions.get(timeline);\n  const subjectMeasurements = details.subjectMeasurements\n  const sourceMeasurements = sourceDetails.get(details.source).sourceMeasurements\n\n  const unresolved = null;\n  if (timeline.phase === 'inactive')\n    return unresolved;\n\n  if (!(timeline instanceof ViewTimeline))\n    return unresolved;\n\n  return calculateRange(phase, sourceMeasurements, subjectMeasurements, details.axis, details.inset);\n}\n\nexport function calculateRange(phase, sourceMeasurements, subjectMeasurements, axis, optionsInset) {\n  // TODO: handle position sticky\n\n  // Determine the view and container size based on the scroll direction.\n  // The view position is the scroll position of the logical starting edge\n  // of the view.\n  const rtl = sourceMeasurements.direction == 'rtl' || sourceMeasurements.writingMode == 'vertical-rl';\n  let viewSize = undefined;\n  let viewPos = undefined;\n  let sizes = {\n    fontSize: subjectMeasurements.fontSize\n  };\n  if (normalizeAxis(axis, sourceMeasurements) === 'x') {\n    viewSize = subjectMeasurements.offsetWidth;\n    viewPos = subjectMeasurements.left;\n    sizes.scrollPadding = [sourceMeasurements.scrollPaddingLeft, sourceMeasurements.scrollPaddingRight];\n    if (rtl) {\n      viewPos += sourceMeasurements.scrollWidth - sourceMeasurements.clientWidth;\n      sizes.scrollPadding = [sourceMeasurements.scrollPaddingRight, sourceMeasurements.scrollPaddingLeft];\n    }\n    sizes.containerSize = sourceMeasurements.clientWidth;\n  } else {\n    // TODO: support sideways-lr\n    viewSize = subjectMeasurements.offsetHeight;\n    viewPos = subjectMeasurements.top;\n    sizes.scrollPadding = [sourceMeasurements.scrollPaddingTop, sourceMeasurements.scrollPaddingBottom];\n    sizes.containerSize = sourceMeasurements.clientHeight;\n  }\n\n  const inset = calculateInset(optionsInset, sizes);\n\n  // Cover:\n  // 0% progress represents the position at which the start border edge of the\n  // element’s principal box coincides with the end edge of its view progress\n  // visibility range.\n  // 100% progress represents the position at which the end border edge of the\n  // element’s principal box coincides with the start edge of its view progress\n  // visibility range.\n  const coverStartOffset = viewPos - sizes.containerSize + inset.end;\n  const coverEndOffset = viewPos + viewSize - inset.start;\n\n  // Contain:\n  // The 0% progress represents the earlier of the following positions:\n  // 1. The start border edge of the element’s principal box coincides with\n  //    the start edge of its view progress visibility range.\n  // 2. The end border edge of the element’s principal box coincides with\n  //    the end edge of its view progress visibility range.\n  // The 100% progress represents the greater of the following positions:\n  // 1. The start border edge of the element’s principal box coincides with\n  //  the start edge of its view progress visibility range.\n  // 2. The end border edge of the element’s principal box coincides with\n  //    the end edge of its view progress visibility range.\n  const alignStartOffset = coverStartOffset + viewSize;\n  const alignEndOffset = coverEndOffset - viewSize;\n  const containStartOffset = Math.min(alignStartOffset, alignEndOffset);\n  const containEndOffset = Math.max(alignStartOffset, alignEndOffset);\n\n  // Entry and Exit bounds align with cover and contains bounds.\n\n  let startOffset = undefined;\n  let endOffset = undefined;\n  // Take inset into account when determining the scrollport size\n  const adjustedScrollportSize = sizes.containerSize - inset.start - inset.end;\n  const subjectIsLargerThanScrollport = viewSize > adjustedScrollportSize;\n\n  switch(phase) {\n    case 'cover':\n      startOffset = coverStartOffset;\n      endOffset = coverEndOffset;\n      break;\n\n    case 'contain':\n      startOffset = containStartOffset;\n      endOffset = containEndOffset;\n      break;\n\n    case 'entry':\n      startOffset = coverStartOffset;\n      endOffset = containStartOffset;\n      break;\n\n    case 'exit':\n      startOffset = containEndOffset;\n      endOffset = coverEndOffset;\n      break;\n\n    case 'entry-crossing':\n      startOffset = coverStartOffset;\n      endOffset = subjectIsLargerThanScrollport ? containEndOffset : containStartOffset;\n      break;\n\n    case 'exit-crossing':\n      startOffset = subjectIsLargerThanScrollport ? containStartOffset : containEndOffset;\n      endOffset = coverEndOffset;\n      break;\n  }\n  return { start: startOffset, end: endOffset };\n}\n\nfunction parseInset(value) {\n  const inset = { start: 0, end: 0 };\n\n  if (!value) return inset;\n\n  let parts;\n  // Parse string parts to\n  if (typeof value === 'string') {\n    parts = splitIntoComponentValues(value).map(str => {\n      if (str === 'auto') {\n        return 'auto';\n      }\n      try {\n        return CSSNumericValue.parse(str);\n      } catch (e) {\n        throw TypeError(`Could not parse inset \"${value}\"`);\n      }\n    });\n  } else if (Array.isArray(value)) {\n    parts = value;\n  } else {\n    parts = [value];\n  }\n  if (parts.length === 0 || parts.length > 2) {\n    throw TypeError('Invalid inset');\n  }\n\n  // Validate that the parts are 'auto' or <length-percentage>\n  for (const part of parts) {\n    if (part === 'auto') {\n      continue;\n    }\n    const type = part.type();\n    if (!(type.length === 1 || type.percent === 1)) {\n      throw TypeError('Invalid inset');\n    }\n  }\n\n  return {\n    start: parts[0],\n    end: parts[1] ?? parts[0]\n  };\n}\n\nfunction calculateInset(value, sizes) {\n  const inset = { start: 0, end: 0 };\n\n  if (!value) return inset;\n\n  const [start, end] = [value.start, value.end].map((part, i) => {\n    if (part === 'auto') {\n      return sizes.scrollPadding[i] === 'auto' ? 0 : parseFloat(sizes.scrollPadding[i]);\n    }\n\n    return resolvePx(part, {\n      percentageReference: CSS.px(sizes.containerSize),\n      fontSize: CSS.px(parseFloat(sizes.fontSize))\n    })\n  });\n\n  return { start, end };\n}\n\n// Calculate the fractional offset of a range value relative to the normal range.\nexport function fractionalOffset(timeline, value) {\n  if (timeline instanceof ViewTimeline) {\n    const { rangeName, offset } = value;\n\n    const phaseRange = range(timeline, rangeName);\n    const coverRange = range(timeline, 'cover');\n\n    return calculateRelativePosition(phaseRange, offset, coverRange, timeline.subject);\n  }\n\n  if (timeline instanceof ScrollTimeline) {\n    const { axis, source } = timeline;\n    const { sourceMeasurements } = sourceDetails.get(source);\n\n    let sourceScrollDistance = undefined;\n    if (normalizeAxis(axis, sourceMeasurements) === 'x') {\n      sourceScrollDistance = sourceMeasurements.scrollWidth - sourceMeasurements.clientWidth;\n    } else {\n      sourceScrollDistance = sourceMeasurements.scrollHeight - sourceMeasurements.clientHeight;\n    }\n\n    // TODO: pass relative measurements (viewport, font-size, root font-size, etc. ) to resolvePx() to resolve relative units\n    const position = resolvePx(value, {percentageReference: CSS.px(sourceScrollDistance)});\n    const fractionalOffset = position / sourceScrollDistance;\n\n    return fractionalOffset;\n  }\n\n  unsupportedTimeline(timeline);\n}\n\nexport function calculateRelativePosition(phaseRange, offset, coverRange, subject) {\n  if (!phaseRange || !coverRange)\n    return 0;\n\n  let style = getComputedStyle(subject)\n  const info = {\n    percentageReference: CSS.px(phaseRange.end - phaseRange.start),\n    fontSize: CSS.px(parseFloat(style.fontSize))\n  };\n\n  const offsetPX = resolvePx(offset, info) + phaseRange.start;\n  return (offsetPX - coverRange.start) / (coverRange.end - coverRange.start);\n}\n\n// https://drafts.csswg.org/scroll-animations-1/#view-progress-timelines\nexport class ViewTimeline extends ScrollTimeline {\n  // As specced, ViewTimeline has a subject and a source, but\n  // ViewTimelineOptions only has source. Furthermore, there is a strict\n  // relationship between subject and source (source is nearest scrollable\n  // ancestor of subject).\n\n  // Proceeding under the assumption that subject will be added to\n  // ViewTimelineOptions. Inferring the source from the subject if not\n  // explicitly set.\n  constructor(options) {\n    super(options);\n    const details = scrollTimelineOptions.get(this);\n    details.subject = options && options.subject ? options.subject : undefined;\n    // TODO: Handle insets.\n    if (options && options.inset) {\n      details.inset = parseInset(options.inset);\n    }\n    if (details.subject) {\n      const resizeObserver = new ResizeObserver(() => {\n        updateMeasurements(details.source)\n      })\n      resizeObserver.observe(details.subject)\n\n      const mutationObserver = new MutationObserver(() => {\n        updateMeasurements(details.source);\n      });\n      mutationObserver.observe(details.subject, {attributes: true, attributeFilter: ['class', 'style']});\n    }\n    validateSource(this);\n    details.subjectMeasurements = measureSubject(details.source, details.subject);\n    updateInternal(this);\n  }\n\n  get source() {\n    validateSource(this);\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set source(source) {\n    throw new Error(\"Cannot set the source of a view timeline\");\n  }\n\n  get subject() {\n    return scrollTimelineOptions.get(this).subject;\n  }\n\n  // The axis is called \"axis\" for a view timeline.\n  // Internally we still call it axis.\n  get axis() {\n    return scrollTimelineOptions.get(this).axis;\n  }\n\n  get currentTime() {\n    const unresolved = null;\n    const scrollPos = directionAwareScrollOffset(this.source, this.axis);\n    if (scrollPos == unresolved)\n      return unresolved;\n\n    const offsets = range(this, 'cover');\n    if (!offsets)\n      return unresolved;\n    const progress =\n        (scrollPos - offsets.start) / (offsets.end - offsets.start);\n\n    return CSS.percent(100 * progress);\n  }\n\n  get startOffset() {\n    return CSS.px(range(this,'cover').start);\n  }\n\n  get endOffset() {\n    return CSS.px(range(this,'cover').end);\n  }\n\n}\n","import {\n  ANIMATION_RANGE_NAMES,\n  ScrollTimeline,\n  addAnimation,\n  removeAnimation,\n  fractionalOffset,\n} from \"./scroll-timeline-base\";\nimport {splitIntoComponentValues} from './utils';\nimport {simplifyCalculation} from './simplify-calculation';\n\nconst nativeDocumentGetAnimations = document.getAnimations;\nconst nativeElementGetAnimations = window.Element.prototype.getAnimations;\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline?.currentTime ?? null;\n    if (timelineTime === null) {\n      return\n    }\n    // Run auto align start time procedure, in case measurements are ready\n    autoAlignStartTime(details);\n    if (details.pendingTask === 'play' && (details.startTime !== null || details.holdTime !== null)) {\n      commitPendingPlay(details);\n    } else if (details.pendingTask === 'pause') {\n      commitPendingPause(details);\n    }\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\n// Converts a time from its internal representation to a percent. For a\n// monotonic timeline, time is reported as a double with implicit units of\n// milliseconds. For progress-based animations, times are reported as\n// percentages.\nfunction toCssNumberish(details, value) {\n  if (value === null)\n    return value;\n\n  if (typeof value !== 'number') {\n      throw new DOMException(\n          `Unexpected value: ${value}.  Cannot convert to CssNumberish`,\n          \"InvalidStateError\");\n  }\n\n  const rangeDuration = details.rangeDuration ?? 100;\n  const limit = effectEnd(details);\n  const percent = limit ?  rangeDuration * value / limit : 0;\n  return CSS.percent(percent);\n}\n\n// Covnerts a time to its internal representation. Progress-based animations\n// use times expressed as percentages. Each progress-based animation is backed\n// by a native animation with a document timeline in the polyfill. Thus, we\n// need to convert the timing from percent to milliseconds with implicit units.\nfunction fromCssNumberish(details, value) {\n  if (!details.timeline) {\n    // Document timeline\n    if (value == null || typeof value === 'number')\n      return value;\n\n    const convertedTime = value.to('ms');\n    if (convertedTime)\n      return convertedTime.value;\n\n    throw new DOMException(\n        \"CSSNumericValue must be either a number or a time value for \" +\n        \"time based animations.\",\n        \"InvalidStateError\");\n  } else {\n    // Scroll timeline.\n    if (value === null)\n      return value;\n\n    if (value.unit === 'percent') {\n      const rangeDuration = details.rangeDuration ?? 100;\n      const duration = effectEnd(details);\n      return value.value * duration / rangeDuration;\n    }\n\n    throw new DOMException(\n        \"CSSNumericValue must be a percentage for progress based animations.\",\n        \"NotSupportedError\");\n  }\n}\n\nfunction normalizedTiming(details) {\n  // Used normalized timing in the case of a progress-based animation or\n  // specified timing with a document timeline.  The normalizedTiming property\n  // is initialized and cached when fetching the timing information.\n  const timing = details.proxy.effect.getTiming();\n  return details.normalizedTiming || timing;\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = fromCssNumberish(details, details.timeline.currentTime);\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n\n  details.animation.pause();\n\n  // Event times are speced as doubles in web-animations-1.\n  // Cannot dispatch a proxy to an event since the proxy is not a fully\n  // transparent replacement. As a workaround, use a custom event and inject\n  // the necessary getters.\n  const finishedEvent =\n    new CustomEvent('finish',\n                    { detail: {\n                      currentTime: details.proxy.currentTime,\n                      timelineTime: details.proxy.timeline.currentTime\n                    }});\n  Object.defineProperty(finishedEvent, 'currentTime', {\n    get: function() { return this.detail.currentTime; }\n  });\n  Object.defineProperty(finishedEvent, 'timelineTime', {\n    get: function() { return this.detail.timelineTime; }\n  });\n\n  requestAnimationFrame(() => {\n    queueMicrotask(() => {\n      details.animation.dispatchEvent(finishedEvent);\n    });\n  });\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\n/**\n * Procedure to silently set the current time of an animation to seek time\n * https://drafts.csswg.org/web-animations-2/#silently-set-the-current-time\n * @param details\n * @param {CSSUnitValue} seekTime\n */\nfunction silentlySetTheCurrentTime(details, seekTime) {\n  // The procedure to silently set the current time of an animation, animation, to seek time is as follows:\n  //  1. If seek time is an unresolved time value, then perform the following steps.\n  //     1.  If the current time is resolved, then throw a TypeError.\n  //     2.  Abort these steps.\n  if (seekTime == null) {\n    if (details.currentTime !== null) {\n      throw new TypeError();\n    }\n  }\n  //  2. Let valid seek time be the result of running the validate a CSSNumberish time procedure with seek time as the input.\n  //  3. If valid seek time is false, abort this procedure.\n  seekTime = fromCssNumberish(details, seekTime);\n\n  //  4. Set auto align start time to false.\n  details.autoAlignStartTime = false;\n\n  //  5. Update either animation’s hold time or start time as follows:\n  //\n  //  5a If any of the following conditions are true:\n  //     - animation’s hold time is resolved, or\n  //     - animation’s start time is unresolved, or\n  //     - animation has no associated timeline or the associated timeline is inactive, or\n  //     - animation’s playback rate is 0,\n  //       1. Set animation’s hold time to seek time.\n  //\n  //  5b Otherwise,\n  //     Set animation’s start time to the result of evaluating timeline time - (seek time / playback rate) where\n  //     timeline time is the current time value of timeline associated with animation.\n  if (details.holdTime !== null || details.startTime === null ||\n    details.timeline.phase === 'inactive' || details.animation.playbackRate === 0) {\n    details.holdTime = seekTime;\n  } else {\n    details.startTime =\n      fromCssNumberish(details, details.timeline.currentTime) - seekTime / details.animation.playbackRate;\n  }\n\n  //  6. If animation has no associated timeline or the associated timeline is inactive, make animation’s start time\n  //     unresolved.\n  //     This preserves the invariant that when we don’t have an active timeline it is only possible to set either the\n  //     start time or the animation’s current time.\n  if (details.timeline.phase === 'inactive') {\n    details.startTime = null;\n  }\n\n  //  7. Make animation’s previous current time unresolved.\n  details.previousCurrentTime = null\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  let unconstrainedCurrentTime =\n      didSeek ? fromCssNumberish(details, details.proxy.currentTime)\n              : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound &&\n        details.previousCurrentTime != null) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = fromCssNumberish(details,\n                                                 details.proxy.currentTime);\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = normalizedTiming(details);\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n\n  return Math.max(0, totalDuration);\n}\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime == null)\n      return;\n\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    setNativeCurrentTime(details,\n                         (timelineTimeMs - details.startTime) *\n                             details.animation.playbackRate);\n  } else if (details.holdTime !== null) {\n    setNativeCurrentTime(details, details.holdTime);\n  }\n}\n\n// Sets the time of the underlying animation, nudging the time slightly if at\n// a scroll-timeline boundary to remain in the active phase.\nfunction setNativeCurrentTime(details, time) {\n  const timeline = details.timeline;\n  const playbackRate = details.animation.playbackRate;\n  const atScrollTimelineBoundary =\n      timeline.currentTime &&\n      timeline.currentTime.value == (playbackRate < 0 ? 0 : 100);\n  const delta =\n      atScrollTimelineBoundary ? (playbackRate < 0 ? 0.001 : -0.001) : 0;\n\n  details.animation.currentTime = time + delta;\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n  //\n  // 4. Let previous current time be the animation’s current time\n  //\n  // 5. Let enable seek be true if the auto-rewind flag is true and has finite timeline is false.\n  //    Otherwise, initialize to false.\n  //\n  // 6. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 6a If animation’s effective playback rate > 0, enable seek is\n  //    true and either animation’s:\n  //      previous current time is unresolved, or\n  //      previous current time < zero, or\n  //      previous current time >= associated effect end,\n  //    6a1. Set the animation’s hold time to zero.\n  //\n  // 6b If animation’s effective playback rate < 0, enable seek is\n  //    true and either animation’s:\n  //      previous current time is unresolved, or\n  //      previous current time is ≤ zero, or\n  //      previous current time is > associated effect end,\n  //    6b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    6b2. Otherwise,\n  //         5b2a Set the animation’s hold time to the animation’s associated effect end.\n  //\n  // 6c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    6c1. Set the animation’s hold time to zero.\n  let previousCurrentTime = fromCssNumberish(details,\n                                             details.proxy.currentTime);\n\n  const playbackRate = effectivePlaybackRate(details);\n  if (playbackRate == 0 && previousCurrentTime == null) {\n    details.holdTime = 0;\n  }\n  // 7. If has finite timeline and previous current time is unresolved:\n  //     Set the flag auto align start time to true.\n  //     NOTE: If play is called for a CSS animation during style update, the animation’s start time cannot be reliably\n  //     calculated until post layout since the start time is to align with the start or end of the animation range\n  //     (depending on the playback rate). In this case, the animation is said to have an auto-aligned start time,\n  //     whereby the start time is automatically adjusted as needed to align the animation’s progress to the\n  //     animation range.\n  if (previousCurrentTime == null) {\n    details.autoAlignStartTime = true;\n  }\n\n  // Not by spec, but required by tests in play-animation.html:\n  // - Playing a finished animation restarts the animation aligned at the start\n  // - Playing a pause-pending but previously finished animation realigns with the scroll position\n  // - Playing a finished animation clears the start time\n  if (details.proxy.playState === 'finished' || abortedPause) {\n    details.holdTime = null\n    details.startTime = null\n    details.autoAlignStartTime = true;\n  }\n\n  // 8. If animation's hold time is resolved, let its start time be\n  //     unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 9. If animation has a pending play task or a pending pause task,\n  //   9.1 Cancel that task.\n  //   9.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 10. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  // Additonal check for polyfill: Does not have the auto align start time flag set.\n  // If we return when this flag is set, a play task will not be scheduled, leaving the animation in the\n  // idle state. If the animation is in the idle state, the auto align procedure will bail.\n  // TODO: update with results of https://github.com/w3c/csswg-drafts/issues/9871\n  if (details.holdTime === null && !details.autoAlignStartTime &&\n      !abortedPause && details.pendingPlaybackRate === null)\n    return;\n\n  // 11. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 12. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // Additional step for the polyfill.\n  // This must run after setting up the ready promise, otherwise we will run\n  // the procedure for calculating auto aligned start time before play state is running\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 13. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (!details) return;\n\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.proxy.playState !== 'paused' && details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  // When updating timeline current time, the start time of any attached animation is conditionally updated. For each\n  // attached animation, run the procedure for calculating an auto-aligned start time.\n  autoAlignStartTime(details);\n\n  if (details.pendingTask) {\n    // Commit pending tasks asynchronously if they are ready after aligning start time\n    requestAnimationFrame(() => {\n      if (details.pendingTask === 'play' && (details.startTime !== null || details.holdTime !== null)) {\n        commitPendingPlay(details);\n      } else if (details.pendingTask === 'pause') {\n        commitPendingPause(details);\n      }\n    });\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    setNativeCurrentTime(\n        details,\n        (timelineTimeMs - fromCssNumberish(details, this.startTime)) *\n            this.playbackRate);\n\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction renormalizeTiming(details) {\n  // Force renormalization.\n  details.specifiedTiming = null;\n}\n\nfunction createProxyEffect(details) {\n  const effect = details.animation.effect;\n  const nativeUpdateTiming = effect.updateTiming;\n\n  // Generic pass-through handler for any method or attribute that is not\n  // explicitly overridden.\n  const handler = {\n    get: function(obj, prop) {\n      const result = obj[prop];\n      if (typeof result === 'function')\n        return result.bind(effect);\n      return result;\n    },\n\n    set: function(obj, prop, value) {\n      obj[prop] = value;\n      return true;\n    }\n  };\n  // Override getComputedTiming to convert to percentages when using a\n  // progress-based timeline.\n  const getComputedTimingHandler = {\n    apply: function(target) {\n      // Ensure that the native animation is using normalized values.\n      effect.getTiming();\n\n      const timing = target.apply(effect);\n\n      if (details.timeline) {\n        const rangeDuration = details.duration ?? 100;\n        timing.localTime = toCssNumberish(details, timing.localTime);\n        timing.endTime = toCssNumberish(details, timing.endTime);\n        timing.activeDuration =\n            toCssNumberish(details, timing.activeDuration);\n        const limit = effectEnd(details);\n        const iteration_duration = timing.iterations ?\n            (limit - timing.delay - timing.endDelay) / timing.iterations : 0;\n        timing.duration = limit ?\n            CSS.percent(rangeDuration * iteration_duration / limit) :\n            CSS.percent(0);\n\n        // Correct for inactive timeline.\n        if (details.timeline.currentTime === undefined) {\n          timing.localTime = null;\n        }\n      }\n      return timing;\n    }\n  };\n  // Override getTiming to normalize the timing. EffectEnd for the animation\n  // align with the range duration.\n  const getTimingHandler = {\n    apply: function(target, thisArg) {\n      // Arbitrary conversion of 100% to ms.\n      const INTERNAL_DURATION_MS = 100000;\n\n      if (details.specifiedTiming)\n        return details.specifiedTiming;\n\n      details.specifiedTiming = target.apply(effect);\n      let timing = Object.assign({}, details.specifiedTiming);\n\n      let totalDuration;\n\n      if (timing.duration === Infinity) {\n        throw TypeError(\n          \"Effect duration cannot be Infinity when used with Scroll \" +\n          \"Timelines\");\n      }\n\n      // Duration 'auto' case.\n      if (timing.duration === null || timing.duration === 'auto' || details.autoDurationEffect) {\n        if (details.timeline) {\n          details.autoDurationEffect = true\n          // TODO: start and end delay are specced as doubles and currently\n          // ignored for a progress based animation. Support delay and endDelay\n          // once CSSNumberish.\n          timing.delay = 0;\n          timing.endDelay = 0;\n          totalDuration = timing.iterations ? INTERNAL_DURATION_MS : 0;\n          timing.duration = timing.iterations\n             ? (totalDuration - timing.delay - timing.endDelay) /\n                 timing.iterations\n             : 0;\n          // When the rangeStart comes after the rangeEnd, we end up in a situation\n          // that cannot work. We can tell this by having ended up with a negative\n          // duration. In that case, we need to adjust the computed timings. We do\n          // this by setting the duration to 0 and then assigning the remainder of\n          // the totalDuration to the endDelay\n          if (timing.duration < 0) {\n            timing.duration = 0;\n            timing.endDelay = totalDuration - timing.delay;\n          }\n          // Set the timing on the native animation to the normalized values\n          // while preserving the specified timing.\n          nativeUpdateTiming.apply(effect, [timing]);\n        }\n      }\n      details.normalizedTiming = timing;\n      return details.specifiedTiming;\n    }\n  };\n  const updateTimingHandler = {\n    apply: function(target, thisArg, argumentsList) {\n      if (!argumentsList || !argumentsList.length)\n        return;\n\n      // Additional validation that is specific to scroll timelines.\n      if (details.timeline && argumentsList[0]) {\n        const options = argumentsList[0];\n        const duration = options.duration;\n        if (duration === Infinity) {\n          throw TypeError(\n              \"Effect duration cannot be Infinity when used with Scroll \" +\n              \"Timelines\");\n        }\n        const iterations = options.iterations;\n        if (iterations === Infinity) {\n          throw TypeError(\n            \"Effect iterations cannot be Infinity when used with Scroll \" +\n            \"Timelines\");\n        }\n\n        if (typeof duration !== 'undefined' && duration !== 'auto') {\n          details.autoDurationEffect = null\n        }\n      }\n\n      // Apply updates on top of the original specified timing.\n      if (details.specifiedTiming) {\n        target.apply(effect, [details.specifiedTiming]);\n      }\n      target.apply(effect, argumentsList);\n      renormalizeTiming(details);\n    }\n  };\n  const proxy = new Proxy(effect, handler);\n  proxy.getComputedTiming = new Proxy(effect.getComputedTiming,\n                                      getComputedTimingHandler);\n  proxy.getTiming = new Proxy(effect.getTiming, getTimingHandler);\n  proxy.updateTiming = new Proxy(effect.updateTiming, updateTimingHandler);\n  return proxy;\n}\n\n// Computes the start delay as a fraction of the active cover range.\nfunction fractionalStartDelay(details) {\n  if (!details.animationRange) return 0;\n  const rangeStart = details.animationRange.start === 'normal' ?\n    getNormalStartRange(details.timeline) :\n    details.animationRange.start;\n  return fractionalOffset(details.timeline, rangeStart);\n}\n\n// Computes the ends delay as a fraction of the active cover range.\nfunction fractionalEndDelay(details) {\n  if (!details.animationRange) return 0;\n  const rangeEnd = details.animationRange.end === 'normal' ?\n    getNormalEndRange(details.timeline) :\n    details.animationRange.end;\n  return 1 - fractionalOffset(details.timeline, rangeEnd);\n}\n\n// Map from an instance of ProxyAnimation to internal details about that animation.\n// See ProxyAnimation constructor for details.\nlet proxyAnimations = new WeakMap();\n\n// Clear cache containing the ProxyAnimation instances when leaving the page.\n// See https://github.com/flackr/scroll-timeline/issues/146#issuecomment-1698159183\n// for details.\nwindow.addEventListener('pagehide', (e) => {\n  proxyAnimations = new WeakMap();\n}, false);\n\n// Map from the real underlying native animation to the ProxyAnimation proxy of it.\nlet proxiedAnimations = new WeakMap();\n\n/**\n * Procedure for calculating an auto-aligned start time.\n * https://drafts.csswg.org/web-animations-2/#animation-calculating-an-auto-aligned-start-time\n * @param details\n */\nfunction autoAlignStartTime(details) {\n  // When attached to a non-monotonic timeline, the start time of the animation may be layout dependent. In this case,\n  // we defer calculation of the start time until the timeline has been updated post layout. When updating timeline\n  // current time, the start time of any attached animation is conditionally updated. The procedure for calculating an\n  // auto-aligned start time is as follows:\n\n  // 1. If the auto-align start time flag is false, abort this procedure.\n  if (!details.autoAlignStartTime) {\n    return;\n  }\n\n  // 2. If the timeline is inactive, abort this procedure.\n  if (!details.timeline || !details.timeline.currentTime) {\n    return;\n  }\n\n  // 3. If play state is idle, abort this procedure.\n  // 4. If play state is paused, and hold time is resolved, abort this procedure.\n  if (details.proxy.playState === 'idle' ||\n    (details.proxy.playState === 'paused' && details.holdTime !== null)) {\n    return;\n  }\n\n  const previousRangeDuration = details.rangeDuration;\n\n  let startOffset, endOffset;\n\n\n  // 5. Let start offset be the resolved timeline time corresponding to the start of the animation attachment range.\n  //    In the case of view timelines, it requires a calculation based on the proportion of the cover range.\n  try {\n    startOffset = CSS.percent(fractionalStartDelay(details) * 100);\n  } catch (e) {\n    // TODO: Validate supported values for range start, to avoid exceptions when resolving the values.\n\n    // Range start is invalid, falling back to default value\n    startOffset = CSS.percent(0);\n    details.animationRange.start = 'normal';\n    console.warn(\"Exception when calculating start offset\", e);\n  }\n\n  // 6. Let end offset be the resolved timeline time corresponding to the end of the animation attachment range.\n  //    In the case of view timelines, it requires a calculation based on the proportion of the cover range.\n  try {\n    endOffset = CSS.percent((1 - fractionalEndDelay(details)) * 100);\n  } catch (e) {\n    // TODO: Validate supported values for range end, to avoid exceptions when resolving the values.\n\n    // Range start is invalid, falling back to default value\n    endOffset = CSS.percent(100);\n    details.animationRange.end = 'normal';\n    console.warn(\"Exception when calculating end offset\", e);\n  }\n\n  // Store the range duration, until we can find a spec aligned method to calculate iteration duration\n  // TODO: Clarify how range duration should be resolved\n  details.rangeDuration = endOffset.value - startOffset.value;\n  // 7. Set start time to start offset if effective playback rate ≥ 0, and end offset otherwise.\n  const playbackRate = effectivePlaybackRate(details);\n  details.startTime = fromCssNumberish(details,playbackRate >= 0 ? startOffset : endOffset);\n\n  // 8. Clear hold time.\n  details.holdTime = null;\n\n  // Additional polyfill step needed to renormalize timing when range has changed\n  if (details.rangeDuration !== previousRangeDuration) {\n    renormalizeTiming(details);\n  }\n}\n\nfunction unsupportedTimeline(timeline) {\n  throw new Error('Unsupported timeline class');\n}\n\nfunction getNormalStartRange(timeline) {\n  if (timeline instanceof ViewTimeline) {\n    return { rangeName: 'cover', offset: CSS.percent(0) };\n  }\n\n  if (timeline instanceof ScrollTimeline) {\n    return CSS.percent(0);\n  }\n\n  unsupportedTimeline(timeline);\n}\n\nfunction getNormalEndRange(timeline) {\n  if (timeline instanceof ViewTimeline) {\n    return { rangeName: 'cover', offset: CSS.percent(100) };\n  }\n\n  if (timeline instanceof ScrollTimeline) {\n    return CSS.percent(100);\n  }\n\n  unsupportedTimeline(timeline);\n}\n\nfunction parseAnimationRange(timeline, value) {\n  if (!value)\n    return {\n      start: 'normal',\n      end: 'normal',\n    };\n\n  const animationRange = {\n    start: getNormalStartRange(timeline),\n    end: getNormalEndRange(timeline),\n  };\n\n  if (timeline instanceof ViewTimeline) {\n    // Format:\n    // <start-name> <start-offset> <end-name> <end-offset>\n    // <name> --> <name> 0% <name> 100%\n    // <name> <start-offset> <end-offset> --> <name> <start-offset>\n    //                                        <name> <end-offset>\n    // <start-offset> <end-offset> --> cover <start-offset> cover <end-offset>\n    // TODO: Support all formatting options once ratified in the spec.\n    const parts = splitIntoComponentValues(value);\n    const rangeNames = [];\n    const offsets = [];\n\n    parts.forEach(part => {\n      if (ANIMATION_RANGE_NAMES.includes(part)) {\n        rangeNames.push(part);\n      } else {\n        try {\n          offsets.push(CSSNumericValue.parse(part));\n        } catch (e) {\n          throw TypeError(`Could not parse range \"${value}\"`);\n        }\n      }\n    });\n\n    if (rangeNames.length > 2 || offsets.length > 2 || offsets.length == 1) {\n      throw TypeError(\"Invalid time range or unsupported time range format.\");\n    }\n\n    if (rangeNames.length) {\n      animationRange.start.rangeName = rangeNames[0];\n      animationRange.end.rangeName = rangeNames.length > 1 ? rangeNames[1] : rangeNames[0];\n    }\n\n    if (offsets.length > 1) {\n      animationRange.start.offset = offsets[0];\n      animationRange.end.offset = offsets[1];\n    }\n\n    return animationRange;\n  }\n\n  if (timeline instanceof ScrollTimeline) {\n    // @TODO: Play nice with only 1 offset being set\n    // @TODO: Play nice with expressions such as `calc(50% + 10px) 100%`\n    const parts = value.split(' ');\n    if (parts.length != 2) {\n      throw TypeError(\"Invalid time range or unsupported time range format.\");\n    }\n\n    animationRange.start = CSSNumericValue.parse(parts[0]);\n    animationRange.end = CSSNumericValue.parse(parts[1]);\n\n    return animationRange;\n  }\n\n  unsupportedTimeline(timeline);\n}\n\nfunction parseTimelineRangePart(timeline, value, position) {\n  if (!value || value === 'normal') return 'normal';\n\n  if (timeline instanceof ViewTimeline) {\n    // Extract parts from the passed in value.\n    let rangeName = 'cover'\n    let offset = position === 'start' ? CSS.percent(0) : CSS.percent(100)\n\n    // Author passed in something like `{ rangeName: 'cover', offset: CSS.percent(100) }`\n    if (value instanceof Object) {\n      if (value.rangeName !== undefined) {\n        rangeName = value.rangeName;\n      }\n\n      if (value.offset !== undefined) {\n        offset = value.offset;\n      }\n    }\n    // Author passed in something like `\"cover 100%\"`\n    else {\n      const parts = splitIntoComponentValues(value);\n\n      if (parts.length === 1) {\n        if (ANIMATION_RANGE_NAMES.includes(parts[0])) {\n          rangeName = parts[0];\n        } else {\n          offset = simplifyCalculation(CSSNumericValue.parse(parts[0]), {});\n        }\n      } else if (parts.length === 2) {\n        rangeName = parts[0];\n        offset = simplifyCalculation(CSSNumericValue.parse(parts[1]), {});\n      }\n    }\n\n    // Validate rangeName\n    if (!ANIMATION_RANGE_NAMES.includes(rangeName)) {\n      throw TypeError(\"Invalid range name\");\n    }\n\n    return { rangeName, offset };\n  }\n\n  if (timeline instanceof ScrollTimeline) {\n    // The value is a standalone offset, so simply parse it.\n    return CSSNumericValue.parse(value);\n  }\n\n  unsupportedTimeline(timeline);\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nexport class ProxyAnimation {\n  constructor(effect, timeline, animOptions={}) {\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    proxiedAnimations.set(animation, this);\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position. These values are represented as floating point\n      // numbers in milliseconds.\n      startTime: null,\n      holdTime: null,\n      rangeDuration: null,\n      previousCurrentTime: null,\n      autoAlignStartTime: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      // Record the specified timing since it may be different than the timing\n      // actually used for the animation. When fetching the timing, this value\n      // will be returned, however, the native animation will use normalized\n      // values.\n      specifiedTiming: null,\n      // The normalized timing has the corrected timing with the intrinsic\n      // iteration duration resolved.\n      normalizedTiming: null,\n      // Effect proxy that performs the necessary time conversions when using a\n      // progress-based timelines.\n      effect: null,\n      // The animation attachment range, restricting the animation’s\n      // active interval to that range of a timeline\n      animationRange: isScrollAnimation ? parseAnimationRange(timeline, animOptions['animation-range']) : null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.effect;\n\n    // Proxy the effect to support timing conversions for progress based\n    // animations.\n    if (!details.effect)\n      details.effect = createProxyEffect(details);\n\n    return details.effect;\n  }\n  set effect(newEffect) {\n    const details = proxyAnimations.get(this);\n    details.animation.effect = newEffect;\n    // Reset proxy to force re-initialization the next time it is accessed.\n    details.effect = null;\n    details.autoDurationEffect = null;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n    const details = proxyAnimations.get(this);\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Set previous progress based in the first condition that applies:\n    //    If previous current time is unresolved:\n    //      Set previous progress to unresolved.\n    //    If endTime time is zero:\n    //      Set previous progress to zero.\n    //    Otherwise\n    //      Set previous progress = previous current time / endTime time\n    let end = effectEnd(details);\n    let previousProgress;\n    if (previousCurrentTime === null) {\n      previousProgress = null\n    } else if (end === 0) {\n      previousProgress = 0;\n    } else {\n      previousProgress = fromCssNumberish(details, previousCurrentTime) / end;\n    }\n\n    // 9. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 10. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 11. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 12. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 11.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Set auto align start time to true.\n      details.autoAlignStartTime = true;\n      // 3. Set start time to unresolved.\n      details.startTime = null;\n      // 4. Set hold time to unresolved.\n      details.holdTime = null;\n\n      // 5. If previous play state is \"finished\" or \"running\"\n      if (previousPlayState === 'running' || previousPlayState === 'finished') {\n        //    1. Schedule a pending play task\n        if (!details.readyPromise || details.readyPromise.state === 'resolved') {\n          createReadyPromise(details);\n        }\n        details.pendingTask = 'play';\n        // Additional polyfill step needed to associate the animation with\n        // the scroll timeline.\n        addAnimation(details.timeline, details.animation,\n                     tickAnimation.bind(this));\n      }\n      // 6. If previous play state is \"paused\" and previous progress is resolved:\n      if (previousPlayState === 'paused' && previousProgress !== null) {\n        //    1. Set hold time to previous progress * endTime time. This step ensures that previous progress is preserved\n        //       even in the case of a pause-pending animation with a resolved start time.\n        details.holdTime = previousProgress * end;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 15. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 16. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 11 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousProgress * effectEnd(details);\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return toCssNumberish(details, details.startTime);\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    // 1. Let valid start time be the result of running the validate a CSSNumberish time procedure with new start time\n    //    as the input.\n    // 2. If valid start time is false, abort this procedure.\n    value = fromCssNumberish(details, value);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 3. Set auto align start time to false.\n    details.autoAlignStartTime = false;\n\n    // 4. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    // 5. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 6. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = fromCssNumberish(details, this.currentTime);\n\n    // 7. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 8. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 9. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 12. If animation has a pending play task or a pending pause task, cancel\n    //     that task and resolve animation’s current ready promise with\n    //     animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 13. Run the procedure to update an animation’s finished state for animation\n   //     with the did seek flag set to true, and the synchronously notify flag\n   //     set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return toCssNumberish(details, details.holdTime);\n\n    return toCssNumberish(details, calculateCurrentTime(details));\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.currentTime = value;\n      return;\n    }\n    // https://drafts.csswg.org/web-animations-2/#setting-the-current-time-of-an-animation\n    // 1. Run the steps to silently set the current time of animation to seek time.\n    silentlySetTheCurrentTime(details, value);\n\n    // 2. If animation has a pending pause task, synchronously complete the pause operation by performing the following steps:\n    //    1. Set animation’s hold time to seek time.\n    //    2. Apply any pending playback rate to animation.\n    //    3. Make animation’s start time unresolved.\n    //    4. Cancel the pending pause task.\n    //    5. Resolve animation’s current ready promise with animation.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = fromCssNumberish(details, value);\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 3. Run the procedure to update an animation’s finished state for animation with the did seek flag set to true,\n    // and the synchronously notify flag set to false.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = fromCssNumberish(details, this.currentTime);\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n\n  get rangeStart() {\n    return proxyAnimations.get(this).animationRange?.start ?? 'normal';\n  }\n\n  set rangeStart(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      return details.animation.rangeStart = value;\n    }\n\n    if (details.timeline instanceof ScrollTimeline) {\n      const animationRange = details.animationRange;\n      animationRange.start = parseTimelineRangePart(details.timeline, value, 'start');\n\n      // Additional polyfill step to ensure that the native animation has the\n      // correct value for current time.\n      autoAlignStartTime(details);\n      syncCurrentTime(details);\n    }\n  }\n\n  get rangeEnd() {\n    return proxyAnimations.get(this).animationRange?.end ?? 'normal';\n  }\n\n  set rangeEnd(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      return details.animation.rangeEnd = value;\n    }\n\n    if (details.timeline instanceof ScrollTimeline) {\n      const animationRange = details.animationRange;\n      animationRange.end = parseTimelineRangePart(details.timeline, value, 'end');\n\n      // Additional polyfill step to ensure that the native animation has the\n      // correct value for current time.\n      autoAlignStartTime(details);\n      syncCurrentTime(details);\n    }\n  }\n\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = toCssNumberish(details, limit);\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n    // and https://drafts.csswg.org/web-animations-2/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // Replaced steps from https://drafts.csswg.org/web-animations-2/#pausing-an-animation-section\n    //\n    // 3. Let has finite timeline be true if animation has an associated timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    // 4. If the animation’s current time is unresolved and has finite timeline is false, perform the steps according\n    //    to the first matching condition below:\n    //\n    //    4a If animation’s playback rate is ≥ 0,\n    //       Set hold time to zero.\n    //    4b Otherwise,\n    //       4b1 If associated effect end for animation is positive infinity,\n    //           throw an \"InvalidStateError\" DOMException and abort these steps.\n    //       4b2 Otherwise,\n    //           Set hold time to animation’s associated effect end.\n    // If has finite timeline is true, and the animation’s current time is unresolved\n    // Set the auto align start time flag to true.\n    if (details.animation.currentTime === null) {\n      details.autoAlignStartTime = true;\n    }\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment where all of the following conditions are true:\n    //\n    //     the user agent has performed any processing necessary to suspend the playback of animation’s associated\n    //     effect, if any.\n    //     the animation is associated with a timeline that is not inactive.\n    //     the animation has a resolved hold time or start time.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n\n    // Additional step for the polyfill.\n    // This must run after setting up the ready promise, otherwise we will run\n    // the procedure for calculating auto aligned start time before play state is running\n    addAnimation(details.timeline, details.animation, tickAnimation.bind(details.proxy));\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime = fromCssNumberish(details, this.currentTime);\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = fromCssNumberish(details,\n                                              details.timeline.currentTime);\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n  \n  set id(value) {\n    proxyAnimations.get(this).animation.id = value;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n\n    const details = proxyAnimations.get(proxyAnimation);\n    details.animationRange = {\n      start: parseTimelineRangePart(timeline, options.rangeStart, 'start'),\n      end: parseTimelineRangePart(timeline, options.rangeEnd, 'end'),\n    };\n\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n}\n\nfunction replaceProxiedAnimations(animationsList) {\n  for (let i = 0; i < animationsList.length; ++i) {\n    let proxyAnimation = proxiedAnimations.get(animationsList[i]);\n    if (proxyAnimation) {\n      animationsList[i] = proxyAnimation;\n    }\n  }\n  return animationsList;\n}\n\nexport function elementGetAnimations(options) {\n  let animations = nativeElementGetAnimations.apply(this, [options]);\n  return replaceProxiedAnimations(animations);\n}\n\nexport function documentGetAnimations(options) {\n  let animations = nativeDocumentGetAnimations.apply(this, [options]);\n  return replaceProxiedAnimations(animations);\n}\n","import { ANIMATION_RANGE_NAMES, getAnonymousSourceElement } from './scroll-timeline-base';\n\n// This is also used in scroll-timeline-css.js\nexport const RegexMatcher = {\n  IDENTIFIER: /[\\w\\\\\\@_-]+/g,\n  WHITE_SPACE: /\\s*/g,\n  NUMBER: /^[0-9]+/,\n  TIME: /^[0-9]+(s|ms)/,\n  SCROLL_TIMELINE: /scroll-timeline\\s*:([^;}]+)/,\n  SCROLL_TIMELINE_NAME: /scroll-timeline-name\\s*:([^;}]+)/,\n  SCROLL_TIMELINE_AXIS: /scroll-timeline-axis\\s*:([^;}]+)/,\n  VIEW_TIMELINE: /view-timeline\\s*:([^;}]+)/,\n  VIEW_TIMELINE_NAME: /view-timeline-name\\s*:([^;}]+)/,\n  VIEW_TIMELINE_AXIS: /view-timeline-axis\\s*:([^;}]+)/,\n  VIEW_TIMELINE_INSET: /view-timeline-inset\\s*:([^;}]+)/,\n  ANIMATION_TIMELINE: /animation-timeline\\s*:([^;}]+)/,\n  ANIMATION_TIME_RANGE: /animation-range\\s*:([^;}]+)/,\n  ANIMATION_NAME: /animation-name\\s*:([^;}]+)/,\n  ANIMATION: /animation\\s*:([^;}]+)/,\n  ANONYMOUS_SCROLL_TIMELINE: /scroll\\(([^)]*)\\)/,\n  ANONYMOUS_VIEW_TIMELINE: /view\\(([^)]*)\\)/,\n};\n\n// Used for ANIMATION_TIMELINE, ANIMATION_NAME and ANIMATION regex\nconst VALUES_CAPTURE_INDEX = 1;\n\nconst WHOLE_MATCH_INDEX = 0;\n\nconst ANIMATION_KEYWORDS = [\n  'normal', 'reverse', 'alternate', 'alternate-reverse',\n  'none', 'forwards', 'backwards', 'both',\n  'running', 'paused',\n  'ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out'\n];\n\nconst TIMELINE_AXIS_TYPES = ['block', 'inline', 'x', 'y'];\nconst ANONYMOUS_TIMELINE_SOURCE_TYPES = ['nearest', 'root', 'self'];\n\n// Parse a styleSheet to extract the relevant elements needed for\n// scroll-driven animations.\n// we will save objects in a list named cssRulesWithTimelineName\nexport class StyleParser {\n  constructor() {\n    this.cssRulesWithTimelineName = [];\n    this.nextAnonymousTimelineNameIndex = 0;\n    this.anonymousScrollTimelineOptions = new Map(); // save anonymous options by name\n    this.anonymousViewTimelineOptions = new Map(); // save anonymous options by name\n    this.sourceSelectorToScrollTimeline = [];\n    this.subjectSelectorToViewTimeline = [];\n    this.keyframeNamesSelectors = new Map();\n  }\n\n  // Inspired by\n  // https://drafts.csswg.org/css-syntax/#parser-diagrams\n  // https://github.com/GoogleChromeLabs/container-query-polyfill/blob/main/src/engine.ts\n  // This function is called twice, in the first pass we are interested in saving\n  // the @keyframe names, in the second pass we will parse other rules to extract\n  // scroll-animations related properties and values.\n  transpileStyleSheet(sheetSrc, firstPass, srcUrl) {\n    // AdhocParser\n    const p = {\n      sheetSrc: sheetSrc,\n      index: 0,\n      name: srcUrl,\n    };\n\n    while (p.index < p.sheetSrc.length) {\n      this.eatWhitespace(p);\n      if (p.index >= p.sheetSrc.length) break;\n      if (this.lookAhead(\"/*\", p)) {\n        while (this.lookAhead(\"/*\", p)) {\n          this.eatComment(p);\n          this.eatWhitespace(p);\n        }\n        continue;\n      }\n\n      const rule = this.parseQualifiedRule(p);\n      if (!rule) continue;\n      if (firstPass)\n        this.parseKeyframesAndSaveNameMapping(rule, p);\n      else\n        this.handleScrollTimelineProps(rule, p);\n    }\n\n    return this.replaceUrlFunctions(p.sheetSrc, srcUrl);\n  }\n\n\n  // If this sheet has no srcURL (like from a <style> tag), we are done.\n  // Otherwise, we have to find `url()` functions and resolve\n  // relative and path-absolute URLs to absolute URLs.\n  replaceUrlFunctions(sheetSrc, srcUrl) {\n    if (!srcUrl) {\n      return sheetSrc;\n    }\n\n    const srcUrlOrigin = new URL(srcUrl).origin\n    const srcUrlDir = srcUrl.lastIndexOf('/') > srcUrlOrigin.length\n        ? srcUrl.substring(0, srcUrl.lastIndexOf('/'))\n        : srcUrlOrigin;\n\n    // replace relative paths\n    sheetSrc = sheetSrc.replace(/url\\((?:(['\"])(?!https?:\\/\\/|data:|blob:|\\/)|(?!['\"]?(?:https?:\\/\\/|data:|blob:|\\/)))(?:\\.\\/)?/gm, `url($1${srcUrlDir}/`)\n\n    // replace path-absolute paths\n    sheetSrc = sheetSrc.replace(/url\\((['\"])?\\//gm, `url($1${srcUrlOrigin}/`)\n\n    return sheetSrc;\n  }\n\n  getAnimationTimelineOptions(animationName, target) {\n    // Rules are pushed to cssRulesWithTimelineName list in the same order as they appear in style sheet.\n    // We are traversing backwards to take the last sample of a rule in a style sheet.\n    // TODO: Rule specificity should be taken into account, i.e. don't just take the last\n    // rule that matches, instead take the one with the most specifity among those that match\n    for (let i = this.cssRulesWithTimelineName.length - 1; i >= 0; i--) {\n      const current = this.cssRulesWithTimelineName[i];\n      try {\n        if (target.matches(current.selector)) {\n          if (!current['animation-name'] || current['animation-name'] == animationName) {\n            return {\n              'animation-timeline': current['animation-timeline'],\n              'animation-range': current['animation-range']\n            }\n          }\n        }\n      } catch {\n        // TODO: handle nested at-rules\n      }\n    }\n\n    return null;\n  }\n\n  getAnonymousScrollTimelineOptions(timelineName, target) {\n    const options = this.anonymousScrollTimelineOptions.get(timelineName);\n    if(options) {\n      return {\n        anonymousSource: options.source,\n        anonymousTarget: target,\n        source: getAnonymousSourceElement(options.source ?? 'nearest', target),\n        axis: (options.axis ? options.axis : 'block'),\n      };\n    }\n\n    return null;\n  }\n\n  getScrollTimelineOptions(timelineName, target) {\n    const anonymousTimelineOptions = this.getAnonymousScrollTimelineOptions(timelineName, target);\n    if(anonymousTimelineOptions)\n      return anonymousTimelineOptions;\n\n    for (let i = this.sourceSelectorToScrollTimeline.length - 1; i >= 0; i--) {\n      const options = this.sourceSelectorToScrollTimeline[i];\n      if(options.name == timelineName) {\n        const source = this.findPreviousSiblingOrAncestorMatchingSelector(target, options.selector);\n\n        if(source) {\n          return {\n            source,\n            ...(options.axis ? { axis: options.axis } : {}),\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  // TODO: Remove this old lookup mechanism and replace it by one that\n  // respects timeline-scope (https://github.com/flackr/scroll-timeline/issues/123)\n  findPreviousSiblingOrAncestorMatchingSelector(target, selector) {\n    // Target self\n    let candidate = target;\n\n    // Walk the DOM tree: preceding siblings and ancestors\n    while (candidate) {\n      if (candidate.matches(selector))\n        return candidate;\n      candidate = candidate.previousElementSibling || candidate.parentElement;\n    }\n\n    // No match\n    return null;\n  }\n\n  getAnonymousViewTimelineOptions(timelineName, target) {\n    const options = this.anonymousViewTimelineOptions.get(timelineName);\n    if(options) {\n      return {\n        subject: target,\n        axis: (options.axis ? options.axis : 'block'),\n        inset: (options.inset ? options.inset : 'auto'),\n      };\n    }\n\n    return null;\n  }\n\n  getViewTimelineOptions(timelineName, target) {\n    const anonymousTimelineOptions = this.getAnonymousViewTimelineOptions(timelineName, target);\n    if(anonymousTimelineOptions)\n      return anonymousTimelineOptions;\n\n    for (let i = this.subjectSelectorToViewTimeline.length - 1; i >= 0; i--) {\n      const options = this.subjectSelectorToViewTimeline[i];\n      if(options.name == timelineName) {\n        const subject = this.findPreviousSiblingOrAncestorMatchingSelector(target, options.selector);\n        if(subject) {\n          return {\n            subject,\n            axis: options.axis,\n            inset: options.inset\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  handleScrollTimelineProps(rule, p) {\n    // The animation-timeline property may not be used in keyframes\n    if (rule.selector.includes(\"@keyframes\")) {\n      return;\n    }\n\n    // TODO is it enough to check with \"includes()\"\n    const hasAnimationName = rule.block.contents.includes(\"animation-name:\");\n    const hasAnimationTimeline = rule.block.contents.includes(\"animation-timeline:\");\n    const hasAnimation = rule.block.contents.includes(\"animation:\");\n\n    this.saveSourceSelectorToScrollTimeline(rule);\n    this.saveSubjectSelectorToViewTimeline(rule);\n\n    if (!hasAnimationTimeline && !hasAnimationName && !hasAnimation) {\n      return;\n    }\n\n    let timelineNames = [];\n    let animationNames = [];\n    let shouldReplacePart = false;\n\n    if (hasAnimationTimeline)\n      timelineNames = this.extractScrollTimelineNames(rule.block.contents);\n\n    if (hasAnimationName)\n      animationNames = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_NAME);\n\n    if (hasAnimationTimeline && hasAnimationName) {\n      this.saveRelationInList(rule, timelineNames, animationNames);\n      return;\n    }\n\n    if (hasAnimation) {\n      this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION)\n        .forEach(shorthand => {\n          const animationName = this.extractAnimationName(shorthand);\n\n          // Save this animation only if there is a scroll timeline.\n          if (animationName && hasAnimationTimeline)\n            animationNames.push(animationName);\n\n          // If there is no duration, animationstart will not happen,\n          // and polyfill will not work which is based on animationstart.\n          // Add 1s as duration to fix this.\n          if(hasAnimationTimeline) {\n            if(!this.hasDuration(shorthand)) {\n\n              // `auto` also is valid duration. Older browsers can’t always\n              // handle it properly, so we remove it from the shorthand.\n              if (this.hasAutoDuration(shorthand)) {\n                rule.block.contents = rule.block.contents.replace(\n                  'auto',\n                  '    '\n                );\n              }\n\n              // TODO: Should keep track of whether duration is artificial or not,\n              // so that we can later track that we need to update timing to\n              // properly see duration as 'auto' for the polyfill.\n              rule.block.contents = rule.block.contents.replace(\n                shorthand, \" 1s \" + shorthand\n              );\n              shouldReplacePart = true;\n            }\n          }\n        });\n    }\n\n    if(shouldReplacePart) {\n      this.replacePart(\n        rule.block.startIndex,\n        rule.block.endIndex,\n        rule.block.contents,\n        p\n      );\n    }\n\n    this.saveRelationInList(rule, timelineNames, animationNames);\n  }\n\n  saveSourceSelectorToScrollTimeline(rule) {\n    const hasScrollTimeline = rule.block.contents.includes(\"scroll-timeline:\");\n    const hasScrollTimelineName = rule.block.contents.includes(\"scroll-timeline-name:\");\n    const hasScrollTimelineAxis = rule.block.contents.includes(\"scroll-timeline-axis:\");\n\n    if(!hasScrollTimeline && !hasScrollTimelineName) return;\n\n    let timelines = [];\n    if(hasScrollTimeline) {\n      const scrollTimelines = this.extractMatches(rule.block.contents, RegexMatcher.SCROLL_TIMELINE);\n      for(const st of scrollTimelines) {\n        const parts = this.split(st);\n        let options = {selector: rule.selector, name: ''};\n\n        if(parts.length == 1) {\n          options.name = parts[0];\n        } else if(parts.length == 2) {\n          if(TIMELINE_AXIS_TYPES.includes(parts[0]))\n            options.axis = parts[0], options.name = parts[1];\n          else\n            options.axis = parts[1], options.name = parts[0];\n        }\n\n        timelines.push(options);\n      }\n    }\n\n    if(hasScrollTimelineName) {\n      const names = this.extractMatches(rule.block.contents, RegexMatcher.SCROLL_TIMELINE_NAME);\n      for(let i = 0; i < names.length; i++) {\n        if(i < timelines.length) {\n          // longhand overrides shorthand\n          timelines[i].name = names[i];\n        } else {\n          let options = {selector: rule.selector, name: names[i]};\n          timelines.push(options);\n        }\n      }\n    }\n\n    let axes = [];\n    if(hasScrollTimelineAxis) {\n      const extractedAxes = this.extractMatches(rule.block.contents, RegexMatcher.SCROLL_TIMELINE_AXIS);\n      axes = extractedAxes.filter(a => TIMELINE_AXIS_TYPES.includes(a));\n      if (axes.length != extractedAxes.length) {\n        throw new Error('Invalid axis');\n      }\n    }\n\n    for(let i = 0; i < timelines.length; i++) {\n      if(axes.length)\n        timelines[i].axis = axes[i % timelines.length];\n    }\n\n    this.sourceSelectorToScrollTimeline.push(...timelines);\n  }\n\n  saveSubjectSelectorToViewTimeline(rule) {\n    const hasViewTimeline = rule.block.contents.includes(\"view-timeline:\");\n    const hasViewTimelineName = rule.block.contents.includes(\"view-timeline-name:\");\n    const hasViewTimelineAxis = rule.block.contents.includes(\"view-timeline-axis:\");\n    const hasViewTimelineInset = rule.block.contents.includes(\"view-timeline-inset:\");\n\n    if(!hasViewTimeline && !hasViewTimelineName) return;\n\n    let timelines = [];\n\n    if(hasViewTimeline) {\n      const viewTimelines = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE);\n      for(let tl of viewTimelines) {\n        const parts = this.split(tl);\n        let options = {selector: rule.selector, name: '', inset: null};\n        if(parts.length == 1) {\n          options.name = parts[0];\n        } else if(parts.length == 2) {\n          if(TIMELINE_AXIS_TYPES.includes(parts[0]))\n            options.axis = parts[0], options.name = parts[1];\n          else\n            options.axis = parts[1], options.name = parts[0];\n        }\n        timelines.push(options);\n      }\n    }\n\n    if(hasViewTimelineName) {\n      const names = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE_NAME);\n      for(let i = 0; i < names.length; i++) {\n        if(i < timelines.length) {\n          // longhand overrides shorthand\n          timelines[i].name = names[i];\n        } else {\n          let options = {selector: rule.selector, name: names[i], inset: null};\n          timelines.push(options);\n        }\n      }\n    }\n\n    let insets = [];\n    let axes = [];\n\n    if(hasViewTimelineInset)\n      insets = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE_INSET);\n\n    if(hasViewTimelineAxis) {\n      const extractedAxes = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE_AXIS);\n      axes = extractedAxes.filter(a => TIMELINE_AXIS_TYPES.includes(a));\n      if (axes.length != extractedAxes.length) {\n        throw new Error('Invalid axis');\n      }\n    }\n\n    for(let i = 0; i < timelines.length; i++) {\n      if(insets.length)\n        timelines[i].inset = insets[i % timelines.length];\n\n      if(axes.length)\n        timelines[i].axis = axes[i % timelines.length];\n    }\n\n    this.subjectSelectorToViewTimeline.push(...timelines);\n  }\n\n  hasDuration(shorthand) {\n    return shorthand.split(\" \").filter(part => isTime(part)).length >= 1;\n  }\n\n  hasAutoDuration(shorthand) {\n    // TODO: Cater for animations that are named auto\n    return shorthand.split(\" \").filter(part => part === 'auto').length >= 1;\n  }\n\n  saveRelationInList(rule, timelineNames, animationNames) {\n    const hasAnimationRange = rule.block.contents.includes(\"animation-range:\");\n    let animationRanges = [];\n\n    if (hasAnimationRange)\n      animationRanges = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_TIME_RANGE);\n\n    const maxLength = Math.max(timelineNames.length, animationNames.length,\n      animationRanges.length);\n\n    for (let i = 0; i < maxLength; i++) {\n      this.cssRulesWithTimelineName.push({\n        selector: rule.selector,\n        'animation-timeline': timelineNames[i % timelineNames.length],\n        ...(animationNames.length ? {'animation-name': animationNames[i % animationNames.length]}: {}),\n        ...(animationRanges.length ? {'animation-range': animationRanges[i % animationRanges.length]}: {}),\n      });\n    }\n  }\n\n  extractScrollTimelineNames(contents) {\n    const value = RegexMatcher.ANIMATION_TIMELINE.exec(contents)[1].trim();\n    const timelineNames = [];\n\n    value.split(\",\").map(part => part.trim()).forEach(part => {\n      if(isAnonymousTimeline(part)) {\n        const name = this.saveAnonymousTimelineName(part);\n        timelineNames.push(name);\n      } else {\n        timelineNames.push(part);\n      }\n    });\n\n    return timelineNames;\n  }\n\n  saveAnonymousTimelineName(part) {\n    // Anonymous scroll timelines are given a name that starts with ':' to\n    // prevent collision with named scroll timelines.\n    const name = `:t${this.nextAnonymousTimelineNameIndex++}`;\n    if (part.startsWith('scroll(')) {\n      this.anonymousScrollTimelineOptions.set(name, this.parseAnonymousScrollTimeline(part));\n    } else {\n      this.anonymousViewTimelineOptions.set(name, this.parseAnonymousViewTimeline(part));\n    }\n    return name;\n  }\n\n  parseAnonymousScrollTimeline(part) {\n    const anonymousMatch = RegexMatcher.ANONYMOUS_SCROLL_TIMELINE.exec(part);\n    if(!anonymousMatch)\n      return null;\n\n    const value = anonymousMatch[VALUES_CAPTURE_INDEX];\n    const options = {};\n    value.split(\" \").forEach(token => {\n      if(TIMELINE_AXIS_TYPES.includes(token)) {\n        options['axis'] = token;\n      } else if(ANONYMOUS_TIMELINE_SOURCE_TYPES.includes(token)) {\n        options['source'] = token;\n      }\n    });\n\n    return options;\n  }\n\n  parseAnonymousViewTimeline(part) {\n    const anonymousMatch = RegexMatcher.ANONYMOUS_VIEW_TIMELINE.exec(part);\n    if(!anonymousMatch)\n      return null;\n\n    // have the same options.\n    const value = anonymousMatch[VALUES_CAPTURE_INDEX];\n    const options = {};\n\n    // TODO: This naive check code also accepts `view(40% block 40%)`, which is not\n    // spec compliant. If two inset values are set, they should be grouped together.\n    value.split(\" \").forEach(token => {\n      if(TIMELINE_AXIS_TYPES.includes(token)) {\n        options['axis'] = token;\n      } else {\n        options['inset'] = options['inset'] ? `${options['inset']} ${token}` : token;\n      }\n    });\n\n    return options;\n  }\n\n  extractAnimationName(shorthand) {\n    return this.findMatchingEntryInContainer(shorthand, this.keyframeNamesSelectors);\n  }\n\n  findMatchingEntryInContainer(shorthand, container) {\n    const matches = shorthand.split(\" \").filter(part => container.has(part))\n    return matches ? matches[0] : null;\n  }\n\n  parseIdentifier(p) {\n    RegexMatcher.IDENTIFIER.lastIndex = p.index;\n    const match = RegexMatcher.IDENTIFIER.exec(p.sheetSrc);\n    if (!match) {\n      throw this.parseError(p, \"Expected an identifier\");\n    }\n    p.index += match[WHOLE_MATCH_INDEX].length;\n    return match[WHOLE_MATCH_INDEX];\n  }\n\n  parseKeyframesAndSaveNameMapping(rule, p) {\n    if (rule.selector.startsWith(\"@keyframes\")) {\n      const mapping = this.replaceKeyframesAndGetMapping(rule, p);\n      rule.selector.split(\" \").forEach((item, index) => {\n        if (index > 0)\n          this.keyframeNamesSelectors.set(item, mapping);\n      })\n    }\n  }\n\n  /*\n  Replaces this:\n    {\n      0% { opacity: 0 }\n      entry 100% { opacity: 1 }\n      exit 0% { opacity: 1 }\n      exit 100% { opacity: 0 }\n      to { opacity: 1 }\n    }\n  with this:\n    {\n      0% { opacity: 0 }\n      20% { opacity: 1 }\n      40% { opacity: 1 }\n      60% { opacity: 0 }\n      80% { opacity: 1 }\n    }\n  and returns a mapping of { \"0.00%\": \"0%\", \"20.00%\" : \"entry 100%\", \"40.00%\" : \"exit 0%\", ... }\n  If there are no phases in the keyframe selectors, nothing will happen\n  and an empty map is returned.\n  This change in keyframes is temporary, and when we are creating ScrollTimeline,\n  if the underlying animation has a mapping, we will calculate new offsets and set new keyframes.\n  */\n  replaceKeyframesAndGetMapping(rule, p) {\n    function hasPhase(selector) {\n      return ANIMATION_RANGE_NAMES.some(phase => selector.startsWith(phase));\n    }\n\n    function cleanFrameSelector(selector) {\n      return selector.split(\" \").map(h => h.trim()).filter(p => p != \"\").join(\" \");\n    }\n\n    function getFrameSelectorIndexes(contents) {\n      let open = 0;\n      let startIndex = -1;\n      let endIndex = -1;\n      const indexes = [];\n\n      for(let i = 0; i < contents.length; i++) {\n        if(contents[i] == '{')\n          open++;\n        else if(contents[i] == '}')\n          open--;\n\n        if(open == 1 && contents[i] != '{' && contents[i] != '}') {\n          if(startIndex == -1)\n            startIndex = i;\n        }\n\n        if(open == 2 && contents[i] == '{') {\n          endIndex = i;\n          indexes.push({start: startIndex, end: endIndex});\n          startIndex = endIndex = -1;\n        }\n      }\n      return indexes;\n    }\n\n    const contents = rule.block.contents;\n    const parts = getFrameSelectorIndexes(contents);\n\n    if(parts.length == 0)\n      return new Map();\n\n    const mapping = new Map();\n    let foundPhaseLinkedOffset = false;\n    const newContents = [];\n    newContents.push(contents.substring(0, parts[0].start));\n    for(let i = 0; i < parts.length; i++) {\n      const allFrameSelectors = contents.substring(parts[i].start, parts[i].end);\n      let replacedFrameSelectors = [];\n\n      allFrameSelectors.split(\",\").forEach(currentFrameSelector => {\n        const trimmedFrameSelector = cleanFrameSelector(currentFrameSelector);\n        // There is no need to treat 'from' and 'to' differently,\n        // Let's say some implicit keyframes for 'from' and 'to' are added to the\n        // keyframes, after we are converting keyframes back, we will ignore them\n        // because they have no presence in the mapping.\n        // TODO: total number of keyframes > 100 is not supported at the moment.\n        const newFrameSelector = mapping.size;\n        mapping.set(newFrameSelector, trimmedFrameSelector);\n        replacedFrameSelectors.push(`${newFrameSelector}%`);\n        if(hasPhase(trimmedFrameSelector))\n          foundPhaseLinkedOffset = true;\n      });\n\n      newContents.push(replacedFrameSelectors.join(\",\"));\n\n      if(i == parts.length-1)\n        newContents.push(contents.substring(parts[i].end));\n      else\n        newContents.push(contents.substring(parts[i].end, parts[i+1].start));\n    }\n\n    if(foundPhaseLinkedOffset) {\n      rule.block.contents = newContents.join(\"\");\n      this.replacePart(\n        rule.block.startIndex,\n        rule.block.endIndex,\n        rule.block.contents,\n        p\n      );\n      return mapping;\n    } else {\n      return new Map();\n    }\n  }\n\n  parseQualifiedRule(p) {\n    const startIndex = p.index;\n    const selector = this.parseSelector(p).trim();\n    if (!selector) return;\n    const block = this.eatBlock(p);\n    const endIndex = p.index;\n    return {\n      selector,\n      block,\n      startIndex,\n      endIndex,\n    };\n  }\n\n  removeEnclosingDoubleQuotes(s) {\n    let startIndex = s[0] == '\"' ? 1 : 0;\n    let endIndex = s[s.length - 1] == '\"' ? s.length - 1 : s.length;\n    return s.substring(startIndex, endIndex);\n  }\n\n  assertString(p, s) {\n    if (p.sheetSrc.substr(p.index, s.length) != s) {\n      throw this.parseError(p, `Did not find expected sequence ${s}`);\n    }\n    p.index += s.length;\n  }\n\n  replacePart(start, end, replacement, p) {\n    p.sheetSrc = p.sheetSrc.slice(0, start) + replacement + p.sheetSrc.slice(end);\n    // If we are pointing past the end of the affected section, we need to\n    // recalculate the string pointer. Pointing to something inside the section\n    // that’s being replaced is undefined behavior. Sue me.\n\n    if (p.index >= end) {\n      const delta = p.index - end;\n      p.index = start + replacement.length + delta;\n    }\n  }\n\n  eatComment(p) {\n    this.assertString(p, \"/*\");\n    this.eatUntil(\"*/\", p, true);\n    this.assertString(p, \"*/\");\n  }\n\n  eatBlock(p) {\n    const startIndex = p.index;\n    this.assertString(p, \"{\");\n    let level = 1;\n    while (level != 0) {\n      if(this.lookAhead(\"/*\", p)) {\n        this.eatComment(p);\n        continue;\n      }\n\n      if (p.sheetSrc[p.index] === \"{\") {\n        level++;\n      } else if (p.sheetSrc[p.index] === \"}\") {\n        level--;\n      }\n      this.advance(p);\n    }\n    const endIndex = p.index;\n    const contents = p.sheetSrc.slice(startIndex, endIndex);\n\n    return { startIndex, endIndex, contents };\n  }\n\n  advance(p) {\n    p.index++;\n    if (p.index > p.sheetSrc.length) {\n      throw this.parseError(p, \"Advanced beyond the end\");\n    }\n  }\n\n  parseError(p, msg) {\n    return Error(`(${p.name ? p.name : '<anonymous file>'}): ${msg}`);\n  }\n\n  eatUntil(s, p, replaceWithSpace=false) {\n    const startIndex = p.index;\n    while (!this.lookAhead(s, p)) {\n      this.advance(p);\n    }\n\n    if(replaceWithSpace) {\n      p.sheetSrc = p.sheetSrc.slice(0, startIndex)\n        + \" \".repeat(p.index - startIndex)\n        + p.sheetSrc.slice(p.index);\n    }\n    return p.sheetSrc.slice(startIndex, p.index);\n  }\n\n  parseSelector(p) {\n    let startIndex = p.index;\n    this.eatUntil(\"{\", p);\n    if (startIndex === p.index) {\n      throw Error(\"Empty selector\");\n    }\n\n    return p.sheetSrc.slice(startIndex, p.index);\n  }\n\n  eatWhitespace(p) {\n    // Start matching at the current position in the sheet src\n    RegexMatcher.WHITE_SPACE.lastIndex = p.index;\n    const match = RegexMatcher.WHITE_SPACE.exec(p.sheetSrc);\n    if (match) {\n      p.index += match[WHOLE_MATCH_INDEX].length;\n    }\n  }\n\n  lookAhead(s, p) {\n    return p.sheetSrc.substr(p.index, s.length) == s;\n  }\n\n  peek(p) {\n    return p.sheetSrc[p.index];\n  }\n\n  extractMatches(contents, matcher, separator=',') {\n    return matcher.exec(contents)[VALUES_CAPTURE_INDEX].trim().split(separator).map(item => item.trim());\n  }\n\n  split(contents) {\n    return contents.split(\" \").map(item => item.trim())\n      .filter(item => item != \"\");\n  }\n}\n\nfunction isAnonymousTimeline(part) {\n  return (part.startsWith(\"scroll\") || part.startsWith(\"view\")) && part.includes(\"(\");\n}\n\nfunction isTime(s) {\n  return RegexMatcher.TIME.exec(s);\n}\n\nfunction isNumber(s) {\n  return RegexMatcher.NUMBER.exec(s);\n}\n\nexport function removeKeywordsFromAnimationShorthand(anim) {\n  return anim.split(' ').filter(\n    (item, index, array) => index == array.length - 1 || !ANIMATION_KEYWORDS.includes(item))\n    .filter(item => !isTime(item) && !isNumber(item));\n}\n","import { StyleParser } from \"./scroll-timeline-css-parser\";\nimport { ProxyAnimation } from \"./proxy-animation\"\nimport { ScrollTimeline, ViewTimeline, getScrollParent, calculateRange,\n  calculateRelativePosition, measureSubject, measureSource } from \"./scroll-timeline-base\";\n\nconst parser = new StyleParser();\n\nfunction initMutationObserver() {\n  const sheetObserver = new MutationObserver((entries) => {\n    for (const entry of entries) {\n      for (const addedNode of entry.addedNodes) {\n        if (addedNode instanceof HTMLStyleElement) {\n          handleStyleTag(addedNode);\n        }\n        if (addedNode instanceof HTMLLinkElement) {\n          handleLinkedStylesheet(addedNode);\n        }\n      }\n    }\n\n    // TODO: Proxy element.style similar to how we proxy element.animate.\n    // We accomplish this by swapping out Element.prototype.style.\n  });\n\n  sheetObserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n  });\n\n  /**\n   * @param {HtmlStyleElement} el style tag to be parsed\n   */\n  function handleStyleTag(el) {\n    // Don’t touch empty style tags nor tags controlled by aphrodite.\n    // Details at https://github.com/Khan/aphrodite/blob/master/src/inject.js,\n    // but any modification to the style tag will break the entire page.\n    if (el.innerHTML.trim().length === 0 || 'aphrodite' in el.dataset) {\n      return;\n    }\n    // TODO: Do with one pass for better performance\n    let newSrc = parser.transpileStyleSheet(el.innerHTML, true);\n    newSrc = parser.transpileStyleSheet(newSrc, false);\n    el.innerHTML = newSrc;\n  }\n\n  function handleLinkedStylesheet(linkElement) {\n    // Filter only css links to external stylesheets.\n    if (linkElement.type != 'text/css' && linkElement.rel != 'stylesheet' || !linkElement.href) {\n      return;\n    }\n    const url = new URL(linkElement.href, document.baseURI);\n    if (url.origin != location.origin) {\n      // Most likely we won't be able to fetch resources from other origins.\n      return;\n    }\n    fetch(linkElement.getAttribute('href')).then(async (response) => {\n      const result = await response.text();\n      let newSrc = parser.transpileStyleSheet(result, true);\n      newSrc = parser.transpileStyleSheet(result, false, response.url);\n      if (newSrc != result) {\n        const blob = new Blob([newSrc], { type: 'text/css' });\n        const url = URL.createObjectURL(blob);\n        linkElement.setAttribute('href', url);\n      }\n    });\n  }\n\n  document.querySelectorAll(\"style\").forEach((tag) => handleStyleTag(tag));\n  document\n    .querySelectorAll(\"link\")\n    .forEach((tag) => handleLinkedStylesheet(tag));\n}\n\nfunction relativePosition(phase, container, target, axis, optionsInset, percent) {\n  const sourceMeasurements = measureSource(container)\n  const subjectMeasurements = measureSubject(container, target)\n  const phaseRange = calculateRange(phase, sourceMeasurements, subjectMeasurements, axis, optionsInset);\n  const coverRange = calculateRange('cover', sourceMeasurements, subjectMeasurements, axis, optionsInset);\n  return calculateRelativePosition(phaseRange, percent, coverRange, target);\n}\n\nfunction createScrollTimeline(anim, animationName, target) {\n  const animOptions = parser.getAnimationTimelineOptions(animationName, target);\n\n  if(!animOptions)\n    return null;\n\n  const timelineName = animOptions['animation-timeline'];\n  if(!timelineName) return null;\n\n  let options = parser.getScrollTimelineOptions(timelineName, target) ||\n    parser.getViewTimelineOptions(timelineName, target);\n  if (!options) return null;\n\n  // If this is a ViewTimeline\n  if(options.subject)\n    updateKeyframesIfNecessary(anim, options);\n\n  return {\n    timeline: options.source ? new ScrollTimeline(options) : new ViewTimeline(options),\n    animOptions: animOptions\n  };\n}\n\nfunction updateKeyframesIfNecessary(anim, options) {\n  const container = getScrollParent(options.subject);\n  const axis = (options.axis || options.axis);\n\n  function calculateNewOffset(mapping, keyframe) {\n    let newOffset = null;\n    for(const [key, value] of mapping) {\n      if(key == keyframe.offset * 100) {\n        if(value == 'from') {\n          newOffset = 0;\n        } else if(value == 'to') {\n          newOffset = 100;\n        } else {\n          const tokens = value.split(\" \");\n          if(tokens.length == 1) {\n            newOffset = parseFloat(tokens[0]);\n          } else {\n            newOffset = relativePosition(tokens[0], container, options.subject,\n              axis, options.inset, CSS.percent(parseFloat(tokens[1]))) * 100;\n          }\n        }\n        break;\n      }\n    }\n\n    return newOffset;\n  }\n\n  const mapping = parser.keyframeNamesSelectors.get(anim.animationName);\n  // mapping is empty when none of the keyframe selectors contains a phase\n  if(mapping && mapping.size) {\n    const newKeyframes = [];\n    anim.effect.getKeyframes().forEach(keyframe => {\n      const newOffset = calculateNewOffset(mapping, keyframe);\n      if(newOffset !== null && newOffset >= 0 && newOffset <= 100) {\n        keyframe.offset = newOffset / 100.0;\n        newKeyframes.push(keyframe);\n      }\n    });\n\n    const sortedKeyframes = newKeyframes.sort((a, b) => {\n      if(a.offset < b.offset) return -1;\n      if(a.affset > b.offset) return 1;\n      return 0;\n    });\n\n    anim.effect.setKeyframes(sortedKeyframes);\n  }\n}\n\nexport function initCSSPolyfill() {\n  // Don't load if browser claims support\n  if (CSS.supports(\"animation-timeline: --works\")) {\n    return true;\n  }\n\n  initMutationObserver();\n\n  // Override CSS.supports() to claim support for the CSS properties from now on\n  const oldSupports = CSS.supports;\n  CSS.supports = (ident) => {\n    ident = ident.replaceAll(/(animation-timeline|scroll-timeline(-(name|axis))?|view-timeline(-(name|axis|inset))?|timeline-scope)\\s*:/g, '--supported-property:');\n    return oldSupports(ident);\n  };\n\n  // We are not wrapping capturing 'animationstart' by a 'load' event,\n  // because we may lose some of the 'animationstart' events by the time 'load' is completed.\n  window.addEventListener('animationstart', (evt) => {\n    evt.target.getAnimations().filter(anim => anim.animationName === evt.animationName).forEach(anim => {\n      const result = createScrollTimeline(anim, anim.animationName, evt.target);\n      if (result) {\n        // If the CSS Animation refers to a scroll or view timeline we need to proxy the animation instance.\n        if (result.timeline && !(anim instanceof ProxyAnimation)) {\n          const proxyAnimation = new ProxyAnimation(anim, result.timeline, result.animOptions);\n          anim.pause();\n          proxyAnimation.play();\n        } else {\n          // If the timeline was removed or the animation was already an instance of a proxy animation,\n          // invoke the set the timeline procedure on the existing animation.\n          anim.timeline = result.timeline;\n        }\n      }\n    });\n  });\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  ViewTimeline,\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  elementGetAnimations,\n  documentGetAnimations,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\n\nimport { initCSSPolyfill } from \"./scroll-timeline-css\"\n\nimport { initPolyfill } from \"./init-polyfill.js\"\n\nfunction initPolyfillIncludingCSS() {\n  // initCSSPolyfill returns true iff the host browser supports SDA\n  if (initCSSPolyfill()) {\n    console.debug(\"Polyfill skipped because browser supports Scroll Timeline.\");\n    return;\n  }\n\n  initPolyfill();\n}\n\ninitPolyfillIncludingCSS();\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  ViewTimeline,\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  elementGetAnimations,\n  documentGetAnimations,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\n\nimport { initCSSPolyfill } from \"./scroll-timeline-css\"\n\nexport function initPolyfill() {\n  // Don't load if browser claims support\n  if (window.ViewTimeline !== undefined) {\n    return true;\n  }\n\n  if (\n    !Reflect.defineProperty(window, 'ScrollTimeline', { value: ScrollTimeline })\n  ) {\n    throw Error(\n      'Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window'\n    );\n  }\n  if (\n    !Reflect.defineProperty(window, 'ViewTimeline', { value: ViewTimeline })\n  ) {\n    throw Error(\n      'Error installing ViewTimeline polyfill: could not attach ViewTimeline to window'\n    );\n  }\n\n  if (\n    !Reflect.defineProperty(Element.prototype, 'animate', { value: animate })\n  ) {\n    throw Error(\n      \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n    );\n  }\n  if (!Reflect.defineProperty(window, 'Animation', { value: ProxyAnimation })) {\n    throw Error('Error installing Animation constructor.');\n  }\n  if (!Reflect.defineProperty(Element.prototype, \"getAnimations\", { value: elementGetAnimations })) {\n    throw Error(\n      \"Error installing ScrollTimeline polyfill: could not attach WAAPI's getAnimations to DOM Element\"\n    );\n  }\n  if (!Reflect.defineProperty(document, \"getAnimations\", { value: documentGetAnimations })) {\n    throw Error(\n      \"Error installing ScrollTimeline polyfill: could not attach WAAPI's getAnimations to document\"\n    );\n  }\n}"],"names":["Token","IdentToken","constructor","value","__publicField","this","FunctionToken","AtKeywordToken","HashToken","type","StringToken","BadStringToken","UrlToken","BadUrlToken","DelimToken","NumberToken","PercentageToken","DimensionToken","unit","WhitespaceToken","CDOToken","CDCToken","ColonToken","SemicolonToken","CommaToken","LeftSquareBracketToken","RightSquareBracketToken","LeftParenthesisToken","RightParenthesisToken","LeftCurlyBracketToken","RightCurlyBracketToken","InputStream","input","consume","codePoint","codePointAt","index","String","fromCodePoint","length","reconsume","peek","codePoints","position","i","nextCodePoint","push","isNewline","isWhitespace","isDigit","isHexDigit","isIdentStartCodePoint","isUppercaseLetter","isLowercaseLetter","isLetter","nonASCIICodePoint","isIdentCodePoint","isNonPrintableCodePoint","validEscape","firstCodePoint","secondCodePoint","startsIdentSequence","thirdCodePoint","startsNumber","consumeEscapedCodePoint","digits","number","parseInt","consumeStringToken","endingCodePoint","stringToken","consumeIdentSequence","result","consumeNumericToken","repr","includes","parseFloat","consumeNumber","consumeRemnantsOfBadUrl","consumeIdentLikeToken","str","match","urlToken","consumeUrlToken","consumeToken","lookahead","hashToken","canonicalUnits","Set","isCanonical","has","toLowerCase","normalizeAxis","axis","computedStyle","Error","horizontalWritingMode","writingMode","TypeError","splitIntoComponentValues","res","consumeComponentValue","level","startIndex","nextChar","slice","test","consumeWhitespace","groupBy","items","key","reduce","groups","item","get","set","Map","partition","callbackFn","partA","partB","simplifyCalculation","root","info","simplifyNumericArray","values","Array","from","map","CSSUnitValue","percentageReference","resolvedValue","resolvedUnit","sum","toSum","fontSize","CSSKeywordValue","Math","E","PI","operator","CSSMathSum","CSSMathProduct","CSSMathNegate","CSSMathClamp","lower","upper","CSSMathInvert","CSSMathMin","CSSMathMax","children","every","child","apply","numeric","rest","unitGroups","some","group","combinedGroups","sumValuesWithSameUnit","numericValues","filter","c","entries","a","numbers","product","failure","baseTypes","fontRelativeLengths","units","viewportRelativeLengths","absoluteLengths","compatible","canonicalUnit","ratios","cm","mm","Q","in","pc","pt","px","angle","deg","grad","rad","turn","time","s","ms","frequency","hz","khz","resolution","dpi","dpcm","dppx","unitToCompatibleUnitsMap","Object","getSetOfCompatibleUnits","productOfTwoUnitMaps","units1","units2","keys","createAType","percent","flex","createSumValue","cssNumericValue","compatibleUnits","tempUnionMap","power","newValues","temp","item1","item2","to","SyntaxError","sumValue","cssUnitValue","oldUnit","oldValue","oldCompatibleUnitGroup","compatibleUnitGroup","convertCSSUnitValue","createCSSUnitValue","sumValueItem","unitMap","entry","multiplyTypes","type1","type2","percentHint","finalType","baseType","CSSFunction","name","CSSSimpleBlock","associatedToken","normalizeIntoTokenStream","isArray","tokens","token","tokenizeString","shift","currentInputToken","endingTokenConstructor","simpleBlock","unshift","consumeSimpleBlock","func","nextToken","consumeFunction","precedence","last","toNAryAstNode","operatorToken","first","second","firstValues","secondValues","transformToCSSNumericValue","node","reifyMathExpression","reifyNumericValue","num","numericValue","operatorStack","tree","o2","pop","convertTokensToAST","simplifiedValue","e","CSSStyleSheet","insertRule","parseCSSNumericValue","cssText","returnValue","parseComponentValue","privateDetails","WeakMap","toCssNumericArray","v","CSSNumericValue","parse","CSSMathValue","opt_name","opt_delimiter","delimiter","toString","details","join","cssOMTypes","displayUnit","super","arguments","invertType","window","CSS","Reflect","defineProperty","forEach","DEFAULT_TIMELINE_AXIS","scrollTimelineOptions","sourceDetails","ANIMATION_RANGE_NAMES","scrollEventSource","source","document","scrollingElement","updateInternal","scrollTimelineInstance","validateSource","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","sourceMeasurements","style","getComputedStyle","currentScrollOffset","scrollTop","abs","scrollLeft","resolvePx","cssValue","timeline","ViewTimeline","anonymousSource","getAnonymousSourceElement","anonymousTarget","updateSource","validateAnonymousSource","subject","display","getScrollParent","isValidAxis","measureSource","scrollWidth","scrollHeight","clientWidth","clientHeight","direction","scrollPaddingTop","scrollPaddingBottom","scrollPaddingLeft","scrollPaddingRight","measureSubject","top","left","ancestor","offsetParent","offsetLeft","offsetTop","clientLeft","clientTop","offsetWidth","offsetHeight","updateMeasurements","ref","timelineRefs","deref","subjectMeasurements","updateScheduled","setTimeout","timelineDetails","oldSource","delete","undefinedRefs","size","disconnect","resizeObserver","ResizeObserver","observe","mutationObserver","MutationObserver","records","record","target","attributes","attributeFilter","scrollListener","addEventListener","removeEventListener","add","WeakRef","removeAnimation","scrollTimeline","animation","splice","addAnimation","queueMicrotask","ScrollTimeline","options","inset","element","duration","phase","container","scrollerStyle","overflow","unresolved","isConnected","scrollPos","maxScrollPos","calculateMaxScrollOffset","__polyfill","findClosestAncestor","matcher","candidate","parentElement","sourceType","isBlockContainer","isFixedElementContainer","transform","perspective","willChange","backdropFilter","isAbsoluteElementContainer","getContainingBlock","body","range","calculateRange","optionsInset","rtl","viewSize","viewPos","sizes","scrollPadding","containerSize","start","end","part","calculateInset","coverStartOffset","coverEndOffset","alignStartOffset","alignEndOffset","containStartOffset","min","containEndOffset","max","startOffset","endOffset","subjectIsLargerThanScrollport","fractionalOffset","rangeName","offset","calculateRelativePosition","sourceScrollDistance","unsupportedTimeline","phaseRange","coverRange","parts","parseInset","offsets","progress","nativeDocumentGetAnimations","getAnimations","nativeElementGetAnimations","Element","prototype","nativeElementAnimate","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","catch","createReadyPromise","readyPromise","requestAnimationFrame","_a","autoAlignStartTime","pendingTask","startTime","holdTime","commitPendingPause","commitPendingPlay","createAbortError","DOMException","toCssNumberish","rangeDuration","limit","effectEnd","fromCssNumberish","convertedTime","applyPendingPlaybackRate","playbackRate","pendingPlaybackRate","currentTimeToMatch","proxy","updateFinishedState","syncCurrentTime","readyTime","commitFinishedNotification","finishedPromise","playState","pause","finishedEvent","CustomEvent","detail","dispatchEvent","effectivePlaybackRate","calculateCurrentTime","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","boundary","previousCurrentTime","calculateStartTime","then","timing","effect","getTiming","normalizedTiming","totalDuration","delay","endDelay","iterations","setNativeCurrentTime","delta","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","bind","proxyAnimations","cancel","timelineTimeMs","renormalizeTiming","specifiedTiming","proxiedAnimations","previousRangeDuration","animationRange","rangeStart","getNormalStartRange","fractionalStartDelay","console","warn","rangeEnd","getNormalEndRange","fractionalEndDelay","unsupportedTimeline$1","parseAnimationRange","rangeNames","split","parseTimelineRangePart","ProxyAnimation","animOptions","isScrollAnimation","nativeUpdateTiming","updateTiming","getComputedTimingHandler","localTime","endTime","activeDuration","iteration_duration","getTimingHandler","thisArg","assign","Infinity","autoDurationEffect","updateTimingHandler","argumentsList","Proxy","obj","prop","getComputedTiming","createProxyEffect","newEffect","newTimeline","oldTimeline","previousPlayState","previousProgress","fromScrollTimeline","toScrollTimeline","play","seekTime","silentlySetTheCurrentTime","replaceState","finish","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","id","resetPendingTasks","onfinish","oncancel","onremove","finished","ready","callback","event","keyframes","proxyAnimation","replaceProxiedAnimations","animationsList","elementGetAnimations","documentGetAnimations","RegexMatcher","IDENTIFIER","WHITE_SPACE","NUMBER","TIME","SCROLL_TIMELINE","SCROLL_TIMELINE_NAME","SCROLL_TIMELINE_AXIS","VIEW_TIMELINE","VIEW_TIMELINE_NAME","VIEW_TIMELINE_AXIS","VIEW_TIMELINE_INSET","ANIMATION_TIMELINE","ANIMATION_TIME_RANGE","ANIMATION_NAME","ANIMATION","ANONYMOUS_SCROLL_TIMELINE","ANONYMOUS_VIEW_TIMELINE","TIMELINE_AXIS_TYPES","ANONYMOUS_TIMELINE_SOURCE_TYPES","parser","cssRulesWithTimelineName","nextAnonymousTimelineNameIndex","anonymousScrollTimelineOptions","anonymousViewTimelineOptions","sourceSelectorToScrollTimeline","subjectSelectorToViewTimeline","keyframeNamesSelectors","transpileStyleSheet","sheetSrc","firstPass","srcUrl","p","eatWhitespace","lookAhead","eatComment","rule","parseQualifiedRule","parseKeyframesAndSaveNameMapping","handleScrollTimelineProps","replaceUrlFunctions","srcUrlOrigin","URL","origin","srcUrlDir","lastIndexOf","substring","replace","getAnimationTimelineOptions","animationName","current","matches","selector","getAnonymousScrollTimelineOptions","timelineName","getScrollTimelineOptions","anonymousTimelineOptions","findPreviousSiblingOrAncestorMatchingSelector","previousElementSibling","getAnonymousViewTimelineOptions","getViewTimelineOptions","hasAnimationName","block","contents","hasAnimationTimeline","hasAnimation","saveSourceSelectorToScrollTimeline","saveSubjectSelectorToViewTimeline","timelineNames","animationNames","shouldReplacePart","extractScrollTimelineNames","extractMatches","shorthand","extractAnimationName","hasDuration","hasAutoDuration","replacePart","endIndex","saveRelationInList","hasScrollTimeline","hasScrollTimelineName","hasScrollTimelineAxis","timelines","scrollTimelines","st","names","axes","extractedAxes","hasViewTimeline","hasViewTimelineName","hasViewTimelineAxis","hasViewTimelineInset","viewTimelines","tl","insets","isTime","exec","animationRanges","maxLength","trim","startsWith","isAnonymousTimeline","saveAnonymousTimelineName","parseAnonymousScrollTimeline","parseAnonymousViewTimeline","anonymousMatch","findMatchingEntryInContainer","parseIdentifier","lastIndex","parseError","mapping","replaceKeyframesAndGetMapping","hasPhase","open","indexes","getFrameSelectorIndexes","foundPhaseLinkedOffset","newContents","allFrameSelectors","replacedFrameSelectors","currentFrameSelector","trimmedFrameSelector","h","newFrameSelector","parseSelector","eatBlock","removeEnclosingDoubleQuotes","assertString","substr","replacement","eatUntil","advance","msg","replaceWithSpace","repeat","separator","relativePosition","createScrollTimeline","anim","calculateNewOffset","keyframe","newOffset","newKeyframes","getKeyframes","sortedKeyframes","sort","b","affset","setKeyframes","updateKeyframesIfNecessary","initCSSPolyfill","supports","handleStyleTag","el","innerHTML","dataset","newSrc","handleLinkedStylesheet","linkElement","rel","href","baseURI","location","fetch","getAttribute","async","response","text","url","blob","Blob","createObjectURL","setAttribute","addedNode","addedNodes","HTMLStyleElement","HTMLLinkElement","documentElement","childList","subtree","querySelectorAll","tag","oldSupports","ident","replaceAll","evt","debug"],"mappings":"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"}